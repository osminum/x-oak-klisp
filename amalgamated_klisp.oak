#!/usr/bin/env oak

// A Klisp written in Oak
// ported over from the Ink implementation at thesephist/klisp.

{
	println: println
	default: default
	clone: clone
	slice: slice
	map: map
	find: find
	reduce: reduce
	fromHex: fromHex
} := import('std')
{
	join: join
	replace: replace
	trim: trim
	endsWith?: endsWith?
} := import('str')
fs := import('fs')

// alias print, because it will be overridden later
oakPrint := print

// like std.reduce, but works on lisp lists
fn reduceSexpr(L, init, f) {
	fn sub(acc, node) if node {
		? -> acc
		_ -> sub(f(acc, node.0), node.1)
	}
	sub(init, L)
}

fn Reader(s) {
	i := 0

	fn peek() s.(i)
	fn peekAhead(n) s.(i + n)
	fn next {
		c := peek()
		i <- i + 1
		c
	}
	fn nextSpan {
		fn sub(acc) if peek() {
			?, ' ', '\n', '\t', '(', ')' -> acc
			_ -> sub(acc << next())
		}
		sub('')
	}
	fn forward {
		fn sub() if peek() {
			' ', '\n', '\t' -> {
				next()
				sub()
			}
			// ignore comments
			';' -> {
				fn sub() if next() {
					? -> ?
					'\n' -> forward()
					_ -> sub()
				}
				sub()
			}
		}
		sub()
	}

	{
		peek: peek
		peekAhead: peekAhead
		next: next
		nextSpan: nextSpan
		forward: forward
	}
}

fn read(s) {
	r := Reader(s |> trim())

	{
		peek: peek
		peekAhead: peekAhead
		next: next
		nextSpan: nextSpan
		forward: forward
	} := r

	// forward through possible comments at start
	forward()

	fn parse() if c := peek() {
		? -> ? // eof
		')' -> ? // halt parsing
		',' -> {
			next()
			forward()
			[:quote, [parse(), ?]]
		}
		'\'' -> {
			next()
			fn sub(acc) if peek() {
				? -> acc
				'\\' -> {
					next()
					sub(
						acc << if d := next() {
							't' -> '\t'
							'n' -> '\n'
							'r' -> '\r'
							'f' -> '\f'
							'x' -> {
								a := peek() |> default(' ')
								b := peekAhead(1) |> default(' ')
								maybeHexDigits := if hex := fromHex(a + b) {
									? -> 'x'
									_ -> {
										next()
										next()
										char(hex)
									}
								}
							}
							_ -> d
						}
					)
				}
				'\'' -> {
					next()
					forward()
					acc
				}
				_ -> sub(acc << next())
			}
			sub('')
		}
		'(' -> {
			next()
			forward()
			fn sub(acc, tail) if peek() {
				? -> acc
				')' -> {
					next()
					forward()
					acc
				}
				'.' -> {
					next()
					forward()
					cons := parse()
					forward()
					acc := if acc {
						? -> cons
						_ -> {
							tail.1 := cons
							acc
						}
					}
					sub(acc, cons)
				}
				_ -> {
					cons := [parse(), ?]
					forward()
					acc := if acc {
						? -> cons
						_ -> {
							tail.1 := cons
							acc
						}
					}
					sub(acc, cons)
				}
			}
			sub(?, ?)
		}
		_ -> {
			span := nextSpan()
			forward()
			if {
				? != x := int(span) -> x
				? != x := float(span) -> x
				span = '_' -> _
				_ -> atom(span)
			}
		}
	}

	term := [parse(), ?]
	prog := [:do, term]
	fn sub(tail) if peek() {
		?, ')' -> prog
		_ -> {
			term := [parse(), ?]
			tail.1 := term
			forward()
			sub(term)
		}
	}
	sub(term)
}

// globally unique sentinel values
LispNull := fn {}
LispEmpty := fn {}

fn getv(env, name, err?) if v := env.(string(name)) {
	? -> if e := env.'-env' {
		? -> {
			if err? -> println('Unbound name "' + string(name) + '"')
			?
		}
		_ -> getv(e, string(name), err?)
	}
	LispNull -> ?
	LispEmpty -> _
	_ -> v
}

fn setv(env, name, v) if type(v) {
	:null -> env.(string(name)) := LispNull
	:empty -> env.(string(name)) := LispEmpty
	_ -> env.(string(name)) := v
}

fn makeFn(f, L) [false, f, L]
fn makeMacro(f, L) [true, f, L]
fn makeNative(f) makeFn(f, ?)

fn eval(L, env) if type(L) {
	:list -> if L.0 {
		:quote -> L.(1).0
		:def -> {
			name := L.(1).0
			val := eval(L.(1).(1).0, env)
			setv(env, name, val)
			val
		}
		:do -> {
			fn sub(form) if form.1 {
				? -> eval(form.0, env)
				_ -> {
					eval(form.0, env)
					sub(form.1)
				}
			}
			sub(L.1)
		}
		:if -> {
			cond := L.(1).0
			conseq := L.(1).(1).0
			altern := L.(1).(1).(1).0
			eval(
				if eval(cond, env) {
					true -> conseq
					_ -> altern
				}
				env
			)
		}
		:fn -> {
			params := L.(1).0
			body := L.(1).(1).0
			makeFn(fn(args) eval(
				body
				{
					fn sub(envc, params, args) if params {
						? -> envc
						_ -> {
							if args { ? -> args <- [LispNull] }
							setv(envc, params.0, args.0)
							sub(envc, params.1, args.1)
						}
					}
					sub({ '-env': env }, params, args)
				}
			), L)
		}
		:macro -> {
			params := L.(1).0
			body := L.(1).(1).0
			makeMacro(fn(args) eval(
				body
				{
					fn sub(envc, params, args) if params {
						? -> envc
						_ -> {
							if args { ? -> args <- [LispNull] }
							setv(envc, params.0, args.0)
							sub(envc, params.1, args.1)
						}
					}
					sub({ '-env': env }, params, [args, ?])
				}
			), L)
		}
		:expand -> {
			expr := eval(L.(1).0, env)
			if {
				expr = ? -> expr
				type(expr.0) = :atom -> if funcStub := getv(env, expr.0, false) {
					[_, _, _] -> if funcStub.0 {
						true -> eval(funcStub.1, env)(expr.1)
						_ -> expr
					}
					_ -> expr
				}
				_ -> expr
			}
		}
		_ -> {
			argcs := L.1
			funcStub := eval(L.0, env)
			func := eval(funcStub.1, env)

			// funcStub.0 reports whether the stub is a macro
			if funcStub.0 {
				true -> func(argcs) |> eval(env)
				_ -> {
					args := [?]
					argcs |> with reduceSexpr(args) fn(head, x) {
						cons := [eval(x, env)]
						head.1 := cons
						cons
					}
					func(args.1)
				}
			}
		}
	}
	:atom -> getv(env, L, true)
	:string -> clone(L)
	_ -> L
}

Env := {
	'true': true
	'false': false
	'car': makeNative(fn(L) if L.0 != ? -> L.(0).0)
	'cdr': makeNative(fn(L) if L.0 != ? -> L.(0).1)
	'car!': makeNative(fn(L) L.(0).0 := L.(1).0)
	'cdr!': makeNative(fn(L) L.(0).1 := L.(1).0)
	'cons': makeNative(fn(L) [L.0, L.(1).0])
	'len': makeNative(fn(L) if type(x := L.0) {
		:string -> len(x)
		:atom -> len(string(x))
		_ -> 0
	})
	'gets': makeNative(fn(L) if type(s := L.0) {
		:string -> slice(
			s
			if L.1 != ? -> int(L.(1).0)
			if L.1 != ? & L.(1).1 != ? -> int(L.(1).(1).0)
		)
		_ -> ''
	})
	'sets!': makeNative(fn(L) if type(s := L.0) {
		:string -> {
			idx := int(L.(1).0)
			s.(idx) := L.(1).(1).0
		}
		_ -> ''
	})

	// ports of Oak's builtins
	'char': makeNative(fn(L) char(int(L.0)))
	'codepoint': makeNative(fn(L) codepoint(L.0))
	'sin': makeNative(fn(L) sin(L.0))
	'cos': makeNative(fn(L) cos(L.0))
	'tan': makeNative(fn(L) tan(L.0))
	'int': makeNative(fn(L) int(L.0))
	'float': makeNative(fn(L) float(L.0))
	'rand': makeNative(rand)
	'time': makeNative(time)
	'args': makeNative(fn(_) {
		fn makeList(xs) if len(xs) {
			0 -> ?
			_ -> [xs.0, makeList(xs |> slice(1))]
		}
		makeList(args())
	})

	// arithmetic and logical operators
	'=': makeNative(fn(L) L.1 |> reduceSexpr(true, fn(acc, x) acc & L.0 = x))
	'<': makeNative(fn(L) if L {
		? -> true
		_ -> {
			last := L.0
			L.1 |> reduceSexpr(true, fn(acc, x) {
				y := acc & last < x
				last <- x
				y
			})
		}
	})
	'>': makeNative(fn(L) if L {
		? -> true
		_ -> {
			last := L.0
			L.1 |> reduceSexpr(true, fn(acc, x) {
				y := acc & last > x
				last <- x
				y
			})
		}
	})
	'+': makeNative(fn(L) L.1 |> reduceSexpr(L.0, fn(a, b) a + b))
	'-': makeNative(fn(L) L.1 |> reduceSexpr(L.0, fn(a, b) a - b))
	'*': makeNative(fn(L) L.1 |> reduceSexpr(L.0, fn(a, b) a * b))
	'/': makeNative(fn(L) L.1 |> reduceSexpr(L.0, fn(a, b) a / b))
	'%': makeNative(fn(L) L.1 |> reduceSexpr(L.0, fn(a, b) a % b))
	'#': makeNative(fn(L) L.1 |> reduceSexpr(L.0, pow))

	// types and conversions
	'type': makeNative(fn(L) if L.0 {
		[_, _, _] -> :function
		[_, _] -> :list
		_ -> if ty := type(L.0) {
			:null -> :nil
			:atom -> :symbol
			_ -> ty
		}
	})
	'string->int': makeNative(fn(L) int(L.0) |> default(0))
	'string->float': makeNative(fn(L) float(L.0) |> default(0))
	'string->symbol': makeNative(fn(L) atom(L.0))
	'->string': makeNative(fn(L) string(L.0))

	// I/O, system
	'print': makeNative(fn(L) {
		output := L.1 |> reduceSexpr(
			if type(L.0) {
				:string -> L.0
				_ -> print(L.0)
			}
			fn(a, b) a + ' ' + if type(b) {
				:string -> b
				_ -> print(b)
			}
		)
		oakPrint(output)
	})
}

// we override "print" for the interpreter, but also need to call print.
// So we alias it to "out".
out := print

fn print(L) if type(L) {
	:null -> '()'
	:empty -> '_'
	:atom -> string(L)
	:string -> '\'' << (L |> replace('\\', '\\\\') |> replace('\'', '\\\'')) << '\''
	:list -> if L {
		[_, _] -> {
			fn sub(term, acc) if term {
				[_, [_, _]] -> sub(term.1, acc << print(term.0))
				[_, ?] -> acc << print(term.0)
				[_, _] -> sub(term.1, acc << print(term.0) << '.')
				_ -> acc << print(term)
			}
			'(' << join(sub(L, []), ' ') << ')'
		}
		[_, _, _] -> if L.2 {
			? -> '(function)'
			_ -> print(L.2)
		}
	}
	_ -> string(L)
}

fn loadLibs(libs, withEnv) {
	fn sub(i, env) if i {
		len(libs) -> withEnv(env)
		_ -> with fs.readFile(libs.(i)) fn(file) {
			file |> read() |> eval(env)
			sub(i + 1, env)
		}
	}
	sub(0, Env |> clone())
}

fn loadLibSources(libs, withEnv) {
	fn sub(i, env) if i {
		len(libs) -> withEnv(env)
		_ -> {
			file := libs.(i)
			file |> read() |> eval(env)
			sub(i + 1, env)
		}
	}
	sub(0, Env |> clone())
}

fn loadStdlib(withEnv) loadLibSources([
	// NOTE: when klisp.oak gets built, these placeholder strings are replaced
	// with the contents of the library source files by the build script.
	//
	// In the Ink-based Klisp CLI, this loading of libraries is asynchronous.
	'; core library

; cons cell shorthands
(def caar
     (fn (x) (car (car x))))
(def cadr
     (fn (x) (car (cdr x))))
(def cdar
     (fn (x) (cdr (car x))))
(def cddr
     (fn (x) (cdr (cdr x))))

; lazy-evaluating boolean combinators
(def !
     (fn (x)
         (if x false true)))
(def &
     (macro (terms)
            (if (= terms ())
              ,true
              (cons ,if
                    (cons (car terms)
                          (cons (cons ,& (cdr terms))
                                (cons ,false ())))))))

(def |
     (macro (terms)
            (if (= terms ())
              ,false
              (cons ,if
                    (cons (car terms)
                          (cons ,true
                                (cons (cons ,| (cdr terms))
                                      ())))))))
(def ^
     (macro (terms)
            (cons ,!
                  (cons (cons ,= terms)
                        ()))))
(def <<
     (fn (x y)
         (if (= (type x) ,string)
           (sets! x (len x) y)
           ; O(n^2) behavior with linked lists
           (do
             (def -<<
                  (fn (x)
                      (if (= x ())
                        (cons y ())
                        (cons (car x)
                              (-<< (cdr x) y)))))
             (-<< x y)))))
(def != ^)

; type assertions
(def nil?
     (fn (x) (= x ())))
(def zero?
     (fn (x) (= x 0)))
(def int?
     (fn (x) (= (type x) ,int)))
(def float?
     (fn (x) (= (type x) ,float)))
(def number?
     (fn (x) (| (int? x) (float? x))))
(def bool?
     (fn (x) (= (type x) ,bool)))
(def string?
     (fn (x) (= (type x) ,string)))
(def symbol?
     (fn (x) (= (type x) ,symbol)))
(def function?
     (fn (x) (= (type x) ,function)))
(def list?
     (fn (x)
         (| (= x ())
            (= (type x) ,list))))

; identity
(def id
     (fn (x) x))
(def is
     (fn (x)
         (fn (y) (= x y))))

; basic math
(def neg
     (fn (n) (- 0 n)))
(def neg?
     (fn (n) (< n 0)))
(def abs
     (fn (n)
         (if (neg? n)
           (neg n)
           n)))
(def sign
     (fn (n)
         (if (neg? n)
           (neg 1)
           1)))
(def sqrt
     (fn (n) (# n 0.5)))
(def even?
     (fn (n) (zero? (% n 2))))
(def odd?
     (fn (n) (! (even? n))))
(def >=
     (fn (a b) (! (< a b))))
(def <=
     (fn (a b) (! (> a b))))
(def inc
     (fn (n) (+ n 1)))
(def dec
     (fn (n) (- n 1)))

; list methods
(def range
     (fn (start end step)
         (do
           (def -range
                (fn (start end step)
                    (if (< start end)
                      (cons start
                            (-range (+ start step) end step))
                      ())))
           (if (nil? step)
             (if (nil? end)
               (-range 0 start 1)
               (-range start end 1))
             (-range start end step)))))

(def nat
     (fn (n) (range 1 (inc n))))

'
	'; core macros

(def gensym
     (fn ()
         (-> (rand)
             (* 100000000)
             int
             ->string
             ((fn (s) (+ \'sym\' s)))
             string->symbol)))

; used for basic macros, not external
(def map-list
     (fn (xs f)
         (if (nil? xs)
           ()
           (cons (f (car xs))
                 (map-list (cdr xs) f)))))

; macros
(def when
     (macro (terms)
            (list ,if (car terms) (cadr terms) ())))

(def unless
     (macro (terms)
            (list ,if (car terms) () (cadr terms))))

(def let
     (macro (terms)
            (do
              (def decl (car terms))
              (def declname (car decl))
              (def declval (cadr decl))
              (def body (cadr terms))
              (list
                (list ,fn (list declname) body)
                declval))))

(def when-let
     (macro (terms)
            (quasiquote
              (let (unquote (car terms))
                (unless (nil? (unquote (caar terms)))
                  (unquote (cadr terms)))))))

(def if-let
     (macro (terms)
            (do
              (def conddecl (car terms))
              (def condname (car conddecl))
              (def if-bodies (cdr terms))
              (def if-conseq (car if-bodies))
              (def if-altern (cadr if-bodies))
              (quasiquote
                (let (unquote conddecl)
                  (if (! (nil? (unquote condname)))
                    (unquote if-conseq)
                    (unquote if-altern)))))))

(def list
     (macro (items)
            ((def -list
                  (fn (items)
                      (if (nil? items)
                        ()
                        (cons ,cons
                              (cons (car items)
                                    (cons (-list (cdr items))
                                          ()))))))
             items)))

(def quasiquote
     (macro (terms)
            (cons
              ,list
              (map-list (car terms)
                        (fn (term)
                            (if (list? term)
                              (if (= ,unquote (car term))
                                (cadr term)
                                (list ,quasiquote term))
                              (list ,quote term)))))))

(def do-times
     (macro (terms)
            (cons ,do
                  (list-of (car terms) (list (cadr terms))))))

(def list-of
     (macro (terms)
            (let (n (car terms))
              (let (f (cadr terms))
                (quasiquote
                  (-> (range (unquote n))
                      (map-list (fn () (unquote f)))))))))

; (default name value)
(def default
     (macro (terms)
            (do
              (def name (car terms))
              (def val (cadr terms))
              (quasiquote
                (if (= (unquote name) ())
                  (def (unquote name) (unquote val))
                  ())))))

; (while condition . body)
(def while
     (macro (terms)
            (do
              (def cndn (car terms))
              (def body (cdr terms))
              (def -while-f (gensym))
              (quasiquote
                ((def (unquote -while-f)
                      (fn ()
                          (if (unquote cndn)
                            (do
                              (unquote (cons ,do body))
                              ((unquote -while-f)))
                            ()))))))))

(def defn
     (macro (terms)
            (quasiquote
              (def (unquote (car terms))
                   (fn (unquote (cadr terms))
                       (unquote (car (cddr terms))))))))

(def defmacro
     (macro (terms)
            (quasiquote
              (def (unquote (car terms))
                   (macro (unquote (cadr terms))
                          (unquote (car (cddr terms))))))))

; (cond (pred body) (pred body) (default-body))
(def cond
     (macro (terms)
            ((def -cond
                  (fn (terms)
                      (if (nil? terms)
                        ()
                        (if (nil? (cdar terms))
                          (caar terms)
                          (quasiquote
                            (if (unquote (car (car terms)))
                              (unquote (cadr (car terms)))
                              (unquote (-cond (cdr terms)))))))))
             terms)))

; (match val (tag body) (tag body) (default-body))
(def match
     (macro (terms)
            (do
              (def -match-val (gensym))
              (def -match
                   (fn (terms)
                       (if (nil? terms)
                         ()
                         (if (nil? (cdar terms))
                           (caar terms)
                           (quasiquote
                             (if (= (unquote -match-val) (unquote (car (car terms))))
                               (unquote (cadr (car terms)))
                               (unquote (-match (cdr terms)))))))))
              (quasiquote
                (let ((unquote -match-val) (unquote (car terms)))
                  (unquote (-match (cdr terms))))))))

; thread-first
(def ->
     (macro (terms)
            (do
              (def apply-partials
                   (fn (partials expr)
                       (if (nil? partials)
                         expr
                         (if (symbol? (car partials))
                           (list (car partials)
                                 (apply-partials (cdr partials) expr))
                           (cons (caar partials)
                                 (cons (apply-partials (cdr partials) expr)
                                       (cdar partials)))))))
              (apply-partials (reverse (cdr terms))
                              (car terms)))))

; thread-last
(def ->>
     (macro (terms)
            (do
              (def apply-partials
                   (fn (partials expr)
                       (if (nil? partials)
                         expr
                         (if (symbol? (car partials))
                           (list (car partials)
                                 (apply-partials (cdr partials) expr))
                           (<< (car partials)
                               (apply-partials (cdr partials) expr))))))
              (apply-partials (reverse (cdr terms))
                              (car terms)))))

; partial application
(def partial
     (macro (terms)
            (let (partial-arg (gensym))
              (list ,fn
                    (list partial-arg)
                    (do
                      (defn -replace-partial-arg (expr)
                            (if (list? expr)
                              (map-list expr -replace-partial-arg)
                              (if (= expr ,?)
                                partial-arg
                                expr)))
                      (-replace-partial-arg (car terms)))))))

; macro expansion functions and macros
(def macroexpand
     (macro (terms)
            (quasiquote (expand (quote (unquote (car terms)))))))

(def expand-all
     (fn (expr)
         (if (list? expr)
           (let (expanded (expand expr))
             (if (list? expanded)
               (if (= expr expanded)
                 (map-list expanded expand-all)
                 (expand-all expanded))
               expanded))
           expr)))

(def macroexpand-all
     (macro (terms)
            (quasiquote (expand-all (quote (unquote (car terms)))))))

; utilities
(def println
     (macro (terms)
            ; we expand the macro manually here
            ; because println should be as fast as possible
            (cons ,do
                  (cons (cons ,print terms)
                        (cons ,(print (char 10))
                              ())))))

(def comment
     ; add "(comment val)" to an expr head
     ; to substitute the expr with "val"
     (macro (terms) (car terms)))

(def log-runtime
     ; prints runtime (finish - start) of an expression
     ; usage: (log-runtime \'label\' (do something))
     (macro (terms)
            (let (-val (gensym))
              (quasiquote
                (do
                  (def start (time))
                  (def (unquote -val) (unquote (cadr terms)))
                  (println (+ \'Runtime for \' (unquote (car terms)) \':\')
                           (->string (* 1000 (- (time) start)))
                           \'ms\')
                  (unquote -val))))))

'
	'; iterator and sequence functions

(defn base-iterator (seq)
      (if (list? seq) () \'\'))

(defn empty? (seq)
      (= seq (base-iterator seq)))

(defn first (seq)
      (if (list? seq)
        (car seq)
        (gets seq 0 1)))

(defn first! (seq x)
      (if (list? seq)
        (car! seq x)
        (sets! seq 0 x)))

(defn rest (seq)
      (if (list? seq)
        (cdr seq)
        (gets seq 1)))

(defn rest! (seq xs)
      (if (list? seq)
        (cdr! seq xs)
        (sets! seq 1 xs)))

(defn conj (x seq)
      (if (list? seq)
        (cons x seq)
        (+ x seq)))

; generic iterator implementations

(defn nth (xs i)
      (if (zero? i)
        (first xs)
        (nth (rest xs) (dec i))))

(defn nth! (xs i x)
      (if (zero? i)
        (first! xs x)
        (nth! (rest xs) (dec i) x)))

(defn second (xs)
      (nth xs 2))

(defn last (xs)
      (if (empty? xs)
        xs
        (if (empty? (rest xs))
          (first xs)
          (last (rest xs)))))

(defn index (xs x)
      (do
        (defn index-from (xs x i)
              (if (empty? xs)
                -1
                (if (= (first xs) x)
                  i
                  (index-from (rest xs) x (inc i)))))
        (index-from xs x 0)))

(defn contains? (xs x)
      (<= 0 (index xs x)))

(defn find (xs f?)
      (do
        (defn find-from (xs f? i)
              (if (empty? xs)
                -1
                (if (f? (first xs))
                  i
                  (find-from (rest xs) f? (inc i)))))
        (find-from xs f? 0)))

(defn some? (xs f?)
      (do
        (default f? id)
        (if (empty? xs)
          false
          (if (f? (first xs))
            true
            (some (rest xs) f?)))))

(defn every? (xs f?)
      (do
        (default f? id)
        (if (empty? xs)
          true
          (if (f? (first xs))
            (every? (rest xs) f?)
            false))))

(defn append (xs ys)
      (if (empty? xs)
        ys
        (conj (first xs)
              (append (rest xs) ys))))

(defn reverse (xs)
      (do
        (defn -reverse (acc xs)
              (if (empty? xs)
                acc
                (-reverse (conj (first xs)
                                acc)
                          (rest xs))))
        (-reverse (base-iterator xs) xs)))

(defn map (xs f)
      (if (empty? xs)
        xs
        (conj (f (first xs))
              (map (rest xs) f))))

(defn reduce (xs acc f)
      (if (empty? xs)
        acc
        (reduce (rest xs)
                (f acc (first xs))
                f)))

(defn filter (xs f?)
      (if (empty? xs)
        xs
        (if (f? (first xs))
          (conj (first xs)
                (filter (rest xs) f?))
          (filter (rest xs) f?))))

(defn exclude (xs f?)
      (if (empty? xs)
        xs
        (if (f? (first xs))
          (exclude (rest xs) f?)
          (conj (first xs)
                (exclude (rest xs) f?)))))

(defn each (xs f)
      (unless (empty? xs)
        (do
          (f (first xs))
          (each (rest xs) f))))

(defn size (xs)
      (if (list? xs)
        (reduce xs 0 inc)
        (len xs)))

(defn zip (xs ys f)
      (do
        (default f (if (list? xs) list +))
        (if (| (empty? xs) (empty? ys))
          ()
          (cons (f (first xs) (first ys))
                (zip (rest xs) (rest ys) f)))))

(defn take (xs n)
      (if (| (empty? xs) (zero? n))
        (base-iterator xs)
        (conj (first xs)
              (take (rest xs) (dec n)))))

(defn take-while (xs f?)
      (if (empty? xs)
        xs
        (if (f? (first xs))
          (conj (first xs)
                (take-while (rest xs) f?))
          (base-iterator xs))))

(defn drop (xs n)
      (if (| (empty? xs) (zero? n))
        xs
        (drop (rest xs) (dec n))))

(defn drop-while (xs f?)
      (if (empty? xs)
        xs
        (if (f? (first xs))
          (drop-while (rest xs) f?)
          xs)))

(defn slice (xs start end)
      (do
        (default start 0)
        (default end (size xs))
        (-> xs
            (drop start)
            (take (- end start)))))

(defn flatten (xs)
      (reduce xs () append))

(defn partition (xs by)
      (match (type by)
             (,nil (partition xs id))
             (,int (do
                     (defn -partition (xs n)
                           (let (tail (drop xs n))
                             (if (empty? tail)
                               (list xs)
                               (conj (take xs n)
                                     (-partition tail n)))))
                     (-partition xs (if (< by 1) 1 by))))
             (,function (do
                          (defn cut-by (xs f)
                                (if (empty? xs)
                                  (list () ())
                                  (let (first-half (conj (first xs)
                                                         (take-while (rest xs)
                                                                     (is (f (first xs))))))
                                    (list first-half
                                          (drop xs (size first-half))))))
                          (defn -partition (xs f)
                                (if (empty? xs)
                                  xs
                                  (do
                                    (def cut (cut-by xs f))
                                    (def first-half (car cut))
                                    (def rest-half (cadr cut))
                                    (conj first-half
                                          (-partition rest-half f)))))
                          (-partition xs by)))))

'
	'; string library, modeled after oak/libstr

(defn char-at (s i)
	  (gets s i (inc i)))

(defn char-between? (c start end)
	  (& (<= start c) (<= c end)))

(defn upper? (c)
	  (char-between? c \'A\' \'Z\'))

(defn lower? (c)
	  (char-between? c \'a\' \'z\'))

(defn digit? (c)
	  (char-between? c \'0\' \'9\'))

(defn space? (c)
	  (| (= c \' \')
		 (= c \'\t\')
		 (= c \'\n\')
		 (= c \'\r\')
		 (= c \'\f\')))

(defn letter? (c)
	  (| (upper? c) (lower? c)))

(defn word? (c)
	  (| (letter? c) (digit? c)))

(defn join (strings joiner)
	  (do
		(default joiner \'\')
		(if (nil? strings)
		  \'\'
		  (do
			(defn -join (acc strings)
				  (if (nil? strings)
					acc
					(-join (+ acc joiner (car strings))
						   (cdr strings))))
			(-join (car strings) (cdr strings))))))

(defn starts-with? (s prefix)
	  (= (gets s 0 (len prefix))
		 prefix))

(defn ends-with? (s suffix)
	  (= (gets s (- (len s) (len prefix)))
		 suffix))

(defn str-index (s substr)
	  (do
		(defn -iter (i)
			  (if (<= (len s) i)
				-1
				(if (= (gets s i (+ i (len substr))) substr)
				  i
				  (-iter (inc i)))))
		(-iter 0)))

(defn str-contains? (s substr)
	  (<= 0 (str-index s substr)))

(defn cut (s sep)
	  (let (cut-at (str-index s sep))
		(list (gets s 0 cut-at)
			  (gets s (+ cut-at (len sep))))))

(defn upper (s)
	  (if (lower? c)
		(char (- (codepoint c) 32))
		c))

(defn lower (s)
	  (if (upper? c)
		(char (+ (codepoint c) 32))
		c))

(defn matches-at? (s substr i)
	  (= (gets s i (+ i (len substr)))
		 substr))

(defn replace (s old new)
	  (if (empty? old)
		s
		(do
		  (def lnew (len new))
		  (def lold (len old))
		  (defn -replace (acc i)
				(if (matches-at? acc old i)
				  (-replace (+ (gets acc 0 i)
							   new
							   (gets acc (+ i lold)))
							(+ i lnew))
				  (if (< i (len acc))
					(-replace acc (inc i))
					acc)))
		  (-replace s 0))))

(defn split (s sep)
	  (if (empty? sep)
		(reduce s (list) <<)
		(do
		  (def lsep (len sep))
		  (defn -split (coll i last)
				(if (matches-at? s sep i)
				  (-split (<< coll (gets s last i))
						  (+ i lsep)
						  (+ i lsep))
				  (if (< i (len s))
					(-split coll (inc i) last)
					(<< coll (gets s last)))))
		  (-split (list) 0 0))))

(defn extend (pad n)
	  (do
		(def times (int (/ n (len pad))))
		(def part (% n (len pad)))
		(defn -extend (base i)
			  (if (zero? i)
				(<< base (gets pad 0 part))
				(-extend (<< base pad)
						 (dec i))))
		(-extend \'\' times)))

(defn pad-start (s n pad)
	  (if (>= (len s) n)
		s
		(+ (extend pad (- n (len s)))
		   s)))

(defn pad-end (s n pad)
	  (if (>= (len s) n)
		s
		(+ s
		   (extend pad (- n (len s))))))

(defn trim-start-space (s)
	  (do
		(defn start (i)
			  (if (space? (char-at s i))
				(start (inc i))
				i))
		(gets s (start 0))))

(defn trim-start-non-empty (s prefix)
	  (do
		(def max (len s))
		(def lpref (len prefix))
		(defn -trim (i)
			  (if (< i max)
				(if (matches-at? s prefix i)
				  (-trim (+ i lpref))
				  i)
				i))
		(gets s (-trim 0))))

(defn trim-start (s prefix)
	  (match prefix
			 (\'\' s)
			 (() (trim-start-space s))
			 ((trim-start-non-empty s prefix))))

(defn trim-end-space (s)
	  (do
		(defn end (i)
			  (if (space? (char-at s i))
				(end (dec i))
				i))
		(gets s 0 (inc (end (dec (len s)))))))

(defn trim-end-non-empty (s suffix)
	  (do
		(def lsuf (len suffix))
		(defn -trim (i)
			  (if (> i -1)
				(if (matches-at? s suffix (- i lsuf))
				  (-trim (- i lsuf))
				  i)
				i))
		(gets s 0 (-trim (len s)))))

(defn trim-end (s suffix)
	  (match suffix
			 (\'\' s)
			 (() (trim-end-space s))
			 ((trim-end-non-empty s suffix))))

(defn trim (s part)
	  (-> s
		  (trim-start part)
		  (trim-end part)))

'
	'; math library

; Euclid\'s GCD algorithm
(defn gcd (a b)
      ; prereq: a < b
      (do
        (defn sub (a b)
              (if (zero? a)
                b
                (sub (% b a) a)))
        (def a (abs a))
        (def b (abs b))
        (if (> a b)
          (sub b a)
          (sub a b))))

; LCM using GCD
(defn lcm (a b)
      (* a (/ b (gcd a b))))

(defn factor? (n c)
      (zero? (% n c)))

; prime filter
(defn prime? (n)
      (if (< n 2)
        false
        (do
          (def max (inc (int (sqrt n))))
          (defn sub (i)
                (if (= i max)
                  true
                  (if (factor? n i)
                    false
                    (sub (inc i)))))
          (sub 2))))

; prime factorize natural number
(defn prime-factors (n)
      (do
        (defn sub (pfs m pf)
              (if (= m 1)
                pfs
                (if (factor? m pf)
                  (sub (cons pf pfs)
                       (/ m pf)
                       pf)
                  (sub pfs
                       m
                       (inc pf)))))
        (reverse (sub () n 2))))

; naive factorize
(defn factors (n)
      (let (first-half (-> (nat (int (sqrt n)))
                           (filter (partial (factor? n ?)))))
        (cond
          ((nil? first-half) first-half)
          ((nil? (cdr first-half)) first-half)
          (true
            (join first-half
                  (let (rev-first-half (reverse first-half))
                    (if (= (car rev-first-half)
                           (/ n (car rev-first-half)))
                      (cdr (map rev-first-half (partial (/ n ?))))
                      (map rev-first-half (partial (/ n ?))))))))))

(def sum
     (fn (ns) (reduce ns 0 +)))

(def prod
     (fn (ns) (reduce ns 1 *)))

(defn mean (xs)
      (/ (sum xs) (size xs)))

(defn geomean (xs)
      (# (prod xs) (/ 1 (size xs))))

(def min
     (fn (xs)
         (if (nil? xs)
           ()
           (reduce xs
                   (car xs)
                   (fn (a b)
                       (if (< a b) a b))))))

(def max
     (fn (xs)
         (if (nil? xs)
           ()
           (reduce xs
                   (car xs)
                   (fn (a b)
                       (if (< a b) b a))))))

'
	'; sort library, implementing quicksort

(defn sort! (xs pred)
      (do
        (default pred id)
        (def vpred (map xs pred))
        (defn partition (xs lo hi)
              (let (pivot (nth vpred lo))
                (do
                  (defn lsub (i)
                        (if (< (nth vpred i) pivot)
                          (lsub (inc i))
                          i))
                  (defn rsub (j)
                        (if (> (nth vpred j) pivot)
                          (rsub (dec j))
                          j))
                  (defn sub (i j)
                        (do
                          (def i (lsub i))
                          (def j (rsub j))
                          (if (< i j)
                            (do
                              (def tmp (nth xs i))
                              (def tmpPred (nth vpred i))
                              (nth! xs i (nth xs j))
                              (nth! xs j tmp)
                              (nth! vpred i (nth vpred j))
                              (nth! vpred j tmpPred)
                              (sub (inc i) (dec j)))
                            j)))
                  (sub lo hi))))
        (defn quicksort (xs lo hi)
              (if (| (< (size xs) 2)
                     (>= lo hi))
                xs
                (let (p (partition xs lo hi))
                  (do
                    (quicksort xs lo p)
                    (quicksort xs (inc p) hi)))))
        (quicksort xs 0 (dec (size xs)))))

(defn sort (xs pred)
      (-> (slice xs)
          (sort! pred)))

'
	'; json library support for encoding/decoding JSON

(defn json/serialize (x)
      ())

(defn json/parse (s)
      ())

'
	'; random library, implementing utilities for working
; with pseudorandom sources of randomness

(defn rand-bool ()
      (< (rand) 0.5))

(defn rand-int (min max)
      (int (rand-number (int min)
                        (int max))))

(defn rand-number (min max)
      (do
        (when (nil? max)
          (do
            (def max min)
            (def min 0)))
        (+ min
           (* (rand) (- max min)))))

(defn rand-choice (xs)
      (nth xs
           (rand-int 0 (size xs))))

'
	'; composites: persistent immutable associative array

; comps store key-value pairs in a list as
; ((key . value) (key . value) (key . value)) for O(n) lookup and O(1) insert.
; Each entry is a single cons cell rather than a list to make value lookup a bit
; more efficient.
(defmacro comp (terms)
  (do
    (def -comp
         (fn (items)
             (if (nil? items)
               ()
               (list ,cons
                     (list ,cons (car items) (cadr items))
                     (-comp (cddr items))))))
    (-comp terms)))

; recursive value lookup by key
(defn getc (cp k v)
      (if (nil? cp)
        v
        (if (= k (caar cp))
          (cdar cp)
          (getc (cdr cp) k v))))

; comps are immutable, and new values are set by adding new entries
; to the head of the comp\'s underlying list. setc does not modify the
; given comp and returns a new comp with the new key, value set.
(defn setc (cp k v)
      (cons (cons k v)
            (exclude cp
                     (partial ((is k) (car ?))))))

; get just the comp keys
(defn keys (cp)
      (map cp car))

; get just the comp values
(defn values (cp)
      (map cp cdr))

; functions with comps

(defn freq (xs)
      (reduce xs
              (comp)
              (fn (counts x)
                  (setc counts
                        x
                        (inc (getc counts x 0))))))

'
	'; utilities for writing tests

(defmacro run-tests (terms)
  (quasiquote
	(let (results (unquote (cons ,list terms)))
	  (let (passed? cadr)
		(do
		  (-> results
			  (exclude passed?)
			  (each (fn (r)
						(let (name (car r))
						  (let (got (car (cddr r)))
							(let (expected (cadr (cddr r)))
							  (println (+ name
										  \': expected \'
										  (->string expected)
										  \', got \'
										  (->string got)))))))))
		  (println (+ (->string (-> results
									(filter passed?)
									size))
					  \'/\'
					  (->string (size results)))
				   \'tests passed.\'))))))

(defmacro test (terms)
  (do
	(def name (car terms))
	(def expected (cadr terms))
	(def body (car (cddr terms)))
	(quasiquote
	  (let (got (unquote body))
		(list (unquote name)
			  (= got (unquote expected)) ; result
			  got (unquote expected))))))

'
], withEnv)

// CLI
with loadStdlib() fn(env) {
	lispFileIdx := if idx := args() |> find(fn(arg) arg |> endsWith?('.klisp') | arg |> endsWith?('.lisp')) {
		-1 -> default(2)
		_ -> idx
	}
	if path := args().(lispFileIdx) {
		? -> {
			println('Klisp interpreter v0.1-oak.')
			fn sub(env) {
				out('λ ')
				with input() fn(evt) if evt.type != :error -> {
					evt.data |>
						read() |>
						eval(env) |>
						print() |>
						println()
					sub(env)
				}
			}
			sub(env)
		}
		_ -> with fs.readFile(path) fn(file) if file {
			? -> println('error: could not read', path)
			_ -> file |> read() |> eval(env)
		}
	}
}

