#!/usr/bin/env oak

// A Klisp written in Oak
// ported over from the Ink implementation at thesephist/klisp.

{
	println: println
	default: default
	clone: clone
	slice: slice
	map: map
	find: find
	reduce: reduce
	fromHex: fromHex
} := import('std')
{
	join: join
	replace: replace
	trim: trim
	endsWith?: endsWith?
} := import('str')
fmt := import('fmt')
fs := import('fs')

// alias print, because it will be overridden later
oakPrint := print

// like std.reduce, but works on lisp lists
fn reduceSexpr(L, init, f) {
	fn sub(acc, node) if node {
		? -> acc
		_ -> sub(f(acc, node.0), node.1)
	}
	sub(init, L)
}

fn Reader(s) {
	i := 0

	fn peek() s.(i)
	fn peekAhead(n) s.(i + n)
	fn next {
		c := peek()
		i <- i + 1
		c
	}
	fn nextSpan {
		fn sub(acc) if peek() {
			?, ' ', '\n', '\t', '(', ')' -> acc
			_ -> sub(acc << next())
		}
		sub('')
	}
	fn forward {
		fn sub() if peek() {
			' ', '\n', '\t' -> {
				next()
				sub()
			}
			// ignore comments
			';' -> {
				fn sub() if next() {
					? -> ?
					'\n' -> forward()
					_ -> sub()
				}
				sub()
			}
		}
		sub()
	}

	{
		peek: peek
		peekAhead: peekAhead
		next: next
		nextSpan: nextSpan
		forward: forward
	}
}

fn read(s) {
	r := Reader(s |> trim())

	{
		peek: peek
		peekAhead: peekAhead
		next: next
		nextSpan: nextSpan
		forward: forward
	} := r

	// forward through possible comments at start
	forward()

	fn parse() if c := peek() {
		? -> ? // eof
		')' -> ? // halt parsing
		',' -> {
			next()
			forward()
			[:quote, [parse(), ?]]
		}
		'\'' -> {
			next()
			fn sub(acc) if peek() {
				? -> acc
				'\\' -> {
					next()
					sub(
						acc << if d := next() {
							't' -> '\t'
							'n' -> '\n'
							'r' -> '\r'
							'f' -> '\f'
							'x' -> {
								a := peek() |> default(' ')
								b := peekAhead(1) |> default(' ')
								maybeHexDigits := if hex := fromHex(a + b) {
									? -> 'x'
									_ -> {
										next()
										next()
										char(hex)
									}
								}
							}
							_ -> d
						}
					)
				}
				'\'' -> {
					next()
					forward()
					acc
				}
				_ -> sub(acc << next())
			}
			sub('')
		}
		'(' -> {
			next()
			forward()
			fn sub(acc, tail) if peek() {
				? -> acc
				')' -> {
					next()
					acc
				}
				'.' -> {
					next()
					forward()
					cons := parse()
					forward()
					acc := if acc {
						? -> cons
						_ -> {
							tail.1 := cons
							acc
						}
					}
					sub(acc, cons)
				}
				_ -> {
					cons := [parse(), ?]
					forward()
					acc := if acc {
						? -> cons
						_ -> {
							tail.1 := cons
							acc
						}
					}
					sub(acc, cons)
				}
			}
			sub(?, ?)
		}
		_ -> {
			span := nextSpan()
			forward()
			if {
				? != x := int(span) -> x
				? != x := float(span) -> x
				span = '_' -> _
				_ -> atom(span)
			}
		}
	}

	term := [parse(), ?]
	prog := [:do, term]
	fn sub(tail) if peek() {
		?, ')' -> prog
		_ -> {
			term := [parse(), ?]
			tail.1 := term
			forward()
			sub(term)
		}
	}
	sub(term)
}

// globally unique sentinel values
LispNull := fn {}
LispEmpty := fn {}

fn getv(env, name) if v := env.(string(name)) {
	? -> if e := env.'-env' {
		? -> ?
		_ -> getv(e, string(name))
	}
	LispNull -> ?
	LispEmpty -> _
	_ -> v
}

fn setv(env, name, v) if type(v) {
	:null -> env.(string(name)) := LispNull
	:empty -> env.(string(name)) := LispEmpty
	_ -> env.(string(name)) := v
}

fn makeFn(f, L) [false, f, L]
fn makeMacro(f, L) [true, f, L]
fn makeNative(f) makeFn(f, ?)

fn eval(L, env) if type(L) {
	:list -> if L.0 {
		:quote -> L.(1).0
		:def -> {
			name := L.(1).0
			val := eval(L.(1).(1).0, env)
			setv(env, name, val)
			val
		}
		:do -> {
			fn sub(form) if form.1 {
				? -> eval(form.0, env)
				_ -> {
					eval(form.0, env)
					sub(form.1)
				}
			}
			sub(L.1)
		}
		:if -> {
			cond := L.(1).0
			conseq := L.(1).(1).0
			altern := L.(1).(1).(1).0
			eval(
				if eval(cond, env) {
					true -> conseq
					_ -> altern
				}
				env
			)
		}
		:fn -> {
			params := L.(1).0
			body := L.(1).(1).0
			makeFn(fn(args) eval(
				body
				{
					fn sub(envc, params, args) if params {
						? -> envc
						_ -> {
							if args { ? -> args <- [LispNull] }
							setv(envc, params.0, args.0)
							sub(envc, params.1, args.1)
						}
					}
					sub({ '-env': env }, params, args)
				}
			), L)
		}
		:macro -> {
			params := L.(1).0
			body := L.(1).(1).0
			makeMacro(fn(args) eval(
				body
				{
					fn sub(envc, params, args) if params {
						? -> envc
						_ -> {
							if args { ? -> args <- [LispNull] }
							setv(envc, params.0, args.0)
							sub(envc, params.1, args.1)
						}
					}
					sub({ '-env': env }, params, [args, ?])
				}
			), L)
		}
		:expand -> if expr := eval(L.(1).0, env) {
			? -> expr
			_ -> if funcStub := eval(expr.0, env) {
				[_, _, _] -> if funcStub.0 {
					true -> eval(funcStub.1, env)(expr.1)
					_ -> expr
				}
				_ -> expr
			}
		}
		_ -> {
			argcs := L.1
			funcStub := eval(L.0, env)
			func := eval(funcStub.1, env)

			// funcStub.0 reports whether the stub is a macro
			if funcStub.0 {
				true -> func(argcs) |> eval(env)
				_ -> {
					args := [?]
					argcs |> with reduceSexpr(args) fn(head, x) {
						cons := [eval(x, env)]
						head.1 := cons
						cons
					}
					func(args.1)
				}
			}
		}
	}
	:atom -> getv(env, L)
	_ -> L
}

Env := {
	'true': true
	'false': false
	'car': makeNative(fn(L) L.(0).0)
	'cdr': makeNative(fn(L) L.(0).1)
	'car!': makeNative(fn(L) L.(0).0 := L.(1).0)
	'cdr!': makeNative(fn(L) L.(0).1 := L.(1).0)
	'cons': makeNative(fn(L) [L.0, L.(1).0])
	'len': makeNative(fn(L) if type(x := L.0) {
		:string -> len(x)
		:atom -> len(string(x))
		_ -> 0
	})
	'gets': makeNative(fn(L) if type(s := L.0) {
		:string -> slice(
			s
			if L.1 != ? -> int(L.(1).0)
			if L.1 != ? & L.(1).1 != ? -> int(L.(1).(1).0)
		)
		_ -> ''
	})
	'sets!': makeNative(fn(L) if type(s := L.0) {
		:string -> {
			idx := int(L.(1).0)
			s.(idx) := L.(1).(1).0
		}
		_ -> ''
	})

	// ports of Oak's builtins
	'char': makeNative(fn(L) char(int(L.0)))
	'point': makeNative(fn(L) codepoint(L.0))
	'pow': makeNative(fn(L) pow(L.0, L.(1).0))
	'sin': makeNative(fn(L) sin(L.0))
	'cos': makeNative(fn(L) cos(L.0))
	'tan': makeNative(fn(L) tan(L.0))
	'int': makeNative(fn(L) int(L.0))
	'float': makeNative(fn(L) float(L.0))
	'rand': makeNative(rand)
	'time': makeNative(time)
	'args': makeNative(fn(_) {
		fn makeList(xs) if len(xs) {
			0 -> ?
			_ -> [xs.0, makeList(xs |> slice(1))]
		}
		makeList(args())
	})

	// arithmetic and logical operators
	'=': makeNative(fn(L) L.1 |> reduceSexpr(true, fn(acc, x) acc & L.0 = x))
	'<': makeNative(fn(L) if L {
		? -> true
		_ -> {
			last := L.0
			L.1 |> reduceSexpr(true, fn(acc, x) {
				y := acc & last < x
				last <- x
				y
			})
		}
	})
	'>': makeNative(fn(L) if L {
		? -> true
		_ -> {
			last := L.0
			L.1 |> reduceSexpr(true, fn(acc, x) {
				y := acc & last > x
				last <- x
				y
			})
		}
	})
	'+': makeNative(fn(L) L.1 |> reduceSexpr(L.0, fn(a, b) a + b))
	'-': makeNative(fn(L) L.1 |> reduceSexpr(L.0, fn(a, b) a - b))
	'*': makeNative(fn(L) L.1 |> reduceSexpr(L.0, fn(a, b) a * b))
	'/': makeNative(fn(L) L.1 |> reduceSexpr(L.0, fn(a, b) a / b))
	'%': makeNative(fn(L) L.1 |> reduceSexpr(L.0, fn(a, b) a % b))
	'#': makeNative(fn(L) L.1 |> reduceSexpr(L.0, pow))

	// types and conversions
	'type': makeNative(fn(L) if L.0 {
		[_, _, _] -> :function
		[_, _] -> :list
		_ -> if ty := type(L.0) {
			:atom -> :symbol
			_ -> ty
		}
	})
	'string->int': makeNative(fn(L) int(L.0) |> default(0))
	'string->float': makeNative(fn(L) float(L.0) |> default(0))
	'string->symbol': makeNative(fn(L) atom(L.0))
	'->string': makeNative(fn(L) string(L.0))

	// I/O, system
	'print': makeNative(fn(L) {
		output := L.1 |> reduceSexpr(
			if type(L.0) {
				:string -> L.0
				_ -> print(L.0)
			}
			fn(a, b) a + ' ' + if type(b) {
				:string -> b
				_ -> print(b)
			}
		)
		oakPrint(output)
	})
}

// we override "print" for the interpreter, but also need to call print.
// So we alias it to "out".
out := print

fn print(L) if type(L) {
	:null -> '()'
	:empty -> '_'
	:atom -> string(L)
	:string -> '\'' << (L |> replace('\\', '\\\\') |> replace('\'', '\\\'')) << '\''
	:list -> if L {
		[_, _] -> {
			fn sub(term, acc) if term {
				[_, [_, _]] -> sub(term.1, acc << print(term.0))
				[_, ?] -> acc << print(term.0)
				[_, _] -> sub(term.1, acc << print(term.0) << '.')
				_ -> acc << print(term)
			}
			'(' << join(sub(L, []), ' ') << ')'
		}
		[_, _, _] -> if L.2 {
			? -> '(function)'
			_ -> print(L.2)
		}
	}
	_ -> string(L)
}

fn loadLibs(libs, withEnv) {
	fn sub(i, env) if i {
		len(libs) -> withEnv(env)
		_ -> with fs.readFile(libs.(i)) fn(file) {
			file |> read() |> eval(env)
			sub(i + 1, env)
		}
	}
	sub(0, Env |> clone())
}

fn loadLibSources(libs, withEnv) {
	fn sub(i, env) if i {
		len(libs) -> withEnv(env)
		_ -> {
			file := libs.(i)
			file |> read() |> eval(env)
			sub(i + 1, env)
		}
	}
	sub(0, Env |> clone())
}

fn loadStdlib(withEnv) loadLibSources([
	// NOTE: when klisp.oak gets built, these placeholder strings are replaced
	// with the contents of the library source files by the build script.
	//
	// In the Ink-based Klisp CLI, this loading of libraries is asynchronous.
	'; core library

; cons cell shorthands
(def caar
     (fn (x) (car (car x))))
(def cadr
     (fn (x) (car (cdr x))))
(def cdar
     (fn (x) (cdr (car x))))
(def cddr
     (fn (x) (cdr (cdr x))))

; lazy-evaluating boolean combinators
(def !
     (fn (x)
         (if x false true)))
(def &
     (macro (terms)
            (if (= terms ())
              ,true
              (cons ,if
                    (cons (car terms)
                          (cons (cons ,& (cdr terms))
                                (cons ,false ())))))))

(def |
     (macro (terms)
            (if (= terms ())
              ,false
              (cons ,if
                    (cons (car terms)
                          (cons ,true
                                (cons (cons ,| (cdr terms))
                                      ())))))))
(def ^
     (macro (terms)
            (cons ,!
                  (cons (cons ,= terms)
                        ()))))
(def <<
     (fn (x y)
         (if (= (type x) ,string)
           (sets! x (len x) y)
           ; O(n^2) behavior with linked lists
           (do
             (def -<<
                  (fn (x)
                      (if (= x ())
                        (cons y ())
                        (cons (car x)
                              (-<< (cdr x) y)))))
             (-<< x y)))))
(def eq? =)
(def not !)
(def and &)
(def or |)
(def != ^)
(def xor ^)
(def neq? ^)

; type assertions
(def nil?
     (fn (x) (= x ())))
(def zero?
     (fn (x) (= x 0)))
(def int?
     (fn (x) (= (type x) ,int)))
(def float?
     (fn (x) (= (type x) ,float)))
(def number?
     (| (int? x) (float? x)))
(def boolean?
     (fn (x) (= (type x) ,boolean)))
(def string?
     (fn (x) (= (type x) ,string)))
(def symbol?
     (fn (x) (= (type x) ,symbol)))
(def function?
     (fn (x) (= (type x) ,function)))
(def list?
     (fn (x) (= (type x) ,list)))
(def pair?
     (fn (x)
         (& (list? x)
            (= (size x) 2))))

; identity
(def id
     (fn (x) x))

(def gensym
     (fn ()
         (-> (rand)
             (* 100000000)
             int
             ->string
             ((fn (s) (+ \'sym\' s)))
             string->symbol)))

; basic math
(def neg
     (fn (n) (- 0 n)))
(def neg?
     (fn (n) (< n 0)))
(def abs
     (fn (n)
         (if (neg? n)
           (neg n)
           n)))
(def sign
     (fn (n)
         (if (neg? n)
           (neg 1)
           1)))
(def sqrt
     (fn (n) (# n 0.5)))
(def even?
     (fn (n) (zero? (% n 2))))
(def odd?
     (fn (n) (! (even? n))))
(def >=
     (fn (a b) (! (< a b))))
(def <=
     (fn (a b) (! (> a b))))
(def inc
     (fn (n) (+ n 1)))
(def dec
     (fn (n) (- n 1)))
(def sum
     (fn (ns) (reduce ns + 0)))
(def prod
     (fn (ns) (reduce ns * 1)))
(def times
     ; repeat x, n times in a list
     (fn (n x)
         (map (range 0 n 1)
              (fn () x))))

; macros
(def when
     (macro (terms)
            (list ,if (car terms) (cadr terms) ())))

(def unless
     (macro (terms)
            (list ,if (car terms) () (cadr terms))))

(def let
     (macro (terms)
            (do
              (def decl (car terms))
              (def declname (car decl))
              (def declval (cadr decl))
              (def body (cadr terms))
              (list
                (list ,fn (list declname) body)
                declval))))

(def when-let
     (macro (terms)
            (quasiquote
              (let (unquote (car terms))
                (unless (nil? (unquote (caar terms)))
                  (unquote (cadr terms)))))))

(def list
     (macro (items)
            ((def -list
                  (fn (items)
                      (if (nil? items)
                        ()
                        (cons ,cons
                              (cons (car items)
                                    (cons (-list (cdr items))
                                          ()))))))
             items)))

(def quasiquote
     (macro (terms)
            (cons
              ,list
              (map (car terms)
                   (fn (term)
                       (if (list? term)
                         (if (= ,unquote (car term))
                           (cadr term)
                           (list ,quasiquote term))
                         (list ,quote term)))))))

(def do-times
     (macro (terms)
            (cons ,do
                  (times (car terms) (list (cadr terms))))))

(def list-of
     (macro (terms)
            (let (n (car terms))
              (let (f (cadr terms))
                (quasiquote
                  (-> (range (unquote n))
                      (map (fn () (unquote f)))))))))

; (default name value)
(def default
     (macro (terms)
            (do
              (def name (car terms))
              (def val (cadr terms))
              (quasiquote
                (if (= (unquote name) ())
                  (def (unquote name) (unquote val))
                  ())))))

; (while condition . body)
(def while
     (macro (terms)
            (do
              (def cndn (car terms))
              (def body (cdr terms))
              (def -while-f (gensym))
              (quasiquote
                ((def (unquote -while-f)
                      (fn ()
                          (if (unquote cndn)
                            (do
                              (unquote (cons ,do body))
                              ((unquote -while-f)))
                            ()))))))))

(def defn
     (macro (terms)
            (quasiquote
              (def (unquote (car terms))
                   (fn (unquote (cadr terms))
                       (unquote (car (cddr terms))))))))

(def defmacro
     (macro (terms)
            (quasiquote
              (def (unquote (car terms))
                   (macro (unquote (cadr terms))
                          (unquote (car (cddr terms))))))))

; (cond (pred body) (pred body) (default-body))
(def cond
     (macro (terms)
            ((def -cond
                  (fn (terms)
                      (if (nil? terms)
                        ()
                        (if (nil? (cdar terms))
                          (caar terms)
                          (quasiquote
                            (if (unquote (car (car terms)))
                              (unquote (cadr (car terms)))
                              (unquote (-cond (cdr terms)))))))))
             terms)))

; (match val (tag body) (tag body) (default-body))
(def match
     (macro (terms)
            (do
              (def -match-val (gensym))
              (def -match
                   (fn (terms)
                       (if (nil? terms)
                         ()
                         (if (nil? (cdar terms))
                           (caar terms)
                           (quasiquote
                             (if (= (unquote -match-val) (unquote (car (car terms))))
                               (unquote (cadr (car terms)))
                               (unquote (-match (cdr terms)))))))))
              (quasiquote
                (let ((unquote -match-val) (unquote (car terms)))
                  (unquote (-match (cdr terms))))))))

; thread-first
(def ->
     (macro (terms)
            (do
              (def apply-partials
                   (fn (partials expr)
                       (if (nil? partials)
                         expr
                         (if (symbol? (car partials))
                           (list (car partials)
                                 (apply-partials (cdr partials) expr))
                           (cons (caar partials)
                                 (cons (apply-partials (cdr partials) expr)
                                       (cdar partials)))))))
              (apply-partials (reverse (cdr terms))
                              (car terms)))))

; thread-last
(def ->>
     (macro (terms)
            (do
              (def apply-partials
                   (fn (partials expr)
                       (if (nil? partials)
                         expr
                         (if (symbol? (car partials))
                           (list (car partials)
                                 (apply-partials (cdr partials) expr))
                           (<< (car partials)
                               (apply-partials (cdr partials) expr))))))
              (apply-partials (reverse (cdr terms))
                              (car terms)))))

; partial application
(def partial
     (macro (terms)
            (let (-partial-arg (gensym))
              (list ,fn
                    (cons -partial-arg ())
                    (map (car terms)
                         (fn (x)
                             (if (= x ,_) -partial-arg x)))))))

; macro expansion functions and macros
(def macroexpand
     (macro (terms)
            (quasiquote (expand (quote (unquote (car terms)))))))

(def expand-all
     (fn (expr)
         (if (list? expr)
           (let (expanded (expand expr))
             (if (list? expanded)
               (map expanded expand-all)
               expanded))
           expr)))

(def macroexpand-all
     (macro (terms)
            (quasiquote (expand-all (quote (unquote (car terms)))))))

; list methods
(def nth
     (fn (xs i)
         (if (zero? i)
           (car xs)
           (nth (cdr xs) (dec i)))))

(def nth?
     (fn (xs i x)
         (if (zero? i)
           (= (car xs) x)
           (nth? (cdr xs) (dec i) x))))

(def nth!
     (fn (xs i x)
         (if (zero? i)
           (car! xs x)
           (nth! (cdr xs) (dec i) x))))

(def first
     (fn (xs)
         (if (nil? xs)
           ()
           (car xs))))

(def last
     (fn (xs)
         (if (nil? xs)
           ()
           (if (nil? (cdr xs))
             (car xs)
             (last (cdr xs))))))

(def index
     (fn (xs x)
         (do
           (def index-from
                (fn (xs x rest)
                    (if (nil? xs)
                      (neg 1)
                      (if (= (car xs) x)
                        rest
                        (index-from (cdr xs) x (inc rest))))))
           (index-from xs x 0))))

(def find
     (fn (xs f?)
         (if (nil? xs)
           ()
           (if (f? (car xs))
             (car xs)
             (find (cdr xs) f?)))))

(def some?
     (fn (xs)
         (if (nil? xs)
           false
           (if (car xs)
             true
             (some? (cdr xs))))))

(def every?
     (fn (xs)
         (if (nil? xs)
           true
           (if (car xs)
             (every? (cdr xs))
             false))))

(def min
     (fn (xs)
         (if (nil? xs)
           ()
           (reduce xs
                   (fn (a b)
                       (if (< a b) a b))
                   (car xs)))))

(def max
     (fn (xs)
         (if (nil? xs)
           ()
           (reduce xs
                   (fn (a b)
                       (if (< a b) b a))
                   (car xs)))))

(def contains?
     (fn (xs x)
         (<= 0 (index xs x))))

(def append
     (fn (xs ys)
         (if (nil? xs)
           ys
           (cons (car xs)
                 (append (cdr xs) ys)))))

(def join
     (fn (xs ys)
         (if (nil? xs)
           ys
           (cons (car xs)
                 (if (nil? (cdr xs))
                   ys
                   (join (cdr xs) ys))))))

(def range
     (fn (start end step)
         (do
           (def -range
                (fn (start end step)
                    (if (< start end)
                      (cons start
                            (-range (+ start step) end step))
                      ())))
           (if (nil? step)
             (if (nil? end)
               (-range 0 start 1)
               (-range start end 1))
             (-range start end step)))))

(def nat
     (fn (n) (range 1 (inc n))))

(def reverse
     (fn (x)
         (do
           (def -reverse
                (fn (acc x)
                    (if (nil? x)
                      acc
                      (-reverse (cons (car x)
                                      acc)
                                (cdr x)))))
           (-reverse () x))))

(def map
     (fn (xs f)
         (if (nil? xs)
           ()
           (cons (f (car xs))
                 (map (cdr xs) f)))))

(def map-deep
     (fn (xs f)
         (map xs (fn (x)
                     (if (list? x)
                       (map-deep x f)
                       (f x))))))

(def reduce
     (fn (xs f acc)
         (if (nil? xs)
           acc
           (reduce (cdr xs) f (f acc (car xs))))))

(def filter
     (fn (xs f)
         (if (nil? xs)
           ()
           (if (f (car xs))
             (cons (car xs)
                   (filter (cdr xs) f))
             (filter (cdr xs) f)))))

(def exclude
     (fn (xs f)
         (if (nil? xs)
           ()
           (if (f (car xs))
             (exclude (cdr xs) f)
             (cons (car xs)
                   (exclude (cdr xs) f))))))

(def each
     (fn (xs f)
         (if (nil? xs)
           ()
           (do
             (f (car xs))
             (each (cdr xs) f)))))

(def size
     (fn (xs)
         (if (nil? xs)
           0
           (inc (size (cdr xs))))))

(def zip-with
     (fn (xs ys f)
         (if (| (nil? xs) (nil? ys))
           ()
           (cons (f (car xs) (car ys))
                 (zip-with (cdr xs) (cdr ys) f)))))

(def zip
     (fn (xs ys)
         (zip-with xs ys list)))

(def take
     (fn (xs n)
         (if (| (nil? xs) (zero? n))
           ()
           (cons (car xs)
                 (take (cdr xs) (dec n))))))

(def drop
     (fn (xs n)
         (if (| (nil? xs) (zero? n))
           xs
           (drop (cdr xs) (dec n)))))

(def slice
     (fn (xs start end)
         (do
           (default start 0)
           (default end (size xs))
           (-> xs
               (drop start)
               (take (- end start))))))

(def flatten
     (fn (xs)
         (reduce xs join ())))

(def partition
     (fn (xs n)
         (if (nil? xs)
           ()
           (cons (take xs n)
                 (partition (drop xs n) n)))))

; string functions
(def cat
     (fn (xs joiner)
         (if (nil? xs)
           \'\'
           (do
             (def cat-onto
                  (fn (xs prefix)
                      (if (nil? xs)
                        prefix
                        (cat-onto (cdr xs)
                                  (+ prefix joiner (car xs))))))
             (cat-onto (cdr xs) (car xs))))))

(def char-at
     (fn (s i)
         (gets s i (inc i))))

; composites: persistent immutable associative array
;
; comps store key-value pairs in a list as
; ((key . value) (key . value) (key . value)) for O(n) lookup and O(1) insert.
; Each entry is a single cons cell rather than a list to make value lookup a bit
; more efficient.
(def comp
     (macro (terms)
            (do
              (def -comp
                   (fn (items)
                       (if (nil? items)
                         ()
                         (list ,cons
                               (list ,cons (car items) (cadr items))
                               (-comp (cddr items))))))
              (-comp terms))))

; recursive value lookup by key
(def getc
     (fn (cp k)
         (if (nil? cp)
           ()
           (if (= k (caar cp))
             (cdar cp)
             (getc (cdr cp) k)))))

; comps are immutable, and new values are set by adding new entries
; to the head of the comp\'s underlying list. setc does not modify the
; given comp and returns a new comp with the new key, value set.
(def setc
     (fn (cp k v)
         (cons (cons k v) cp)))

; get just the comp keys
(def keys
     (fn (cp)
         (map cp car)))

; get just the comp values
(def values
     (fn (cp)
         (map cp cdr)))

; utilities
(def println
     (macro (terms)
            ; we expand the macro manually here
            ; because println should be as fast as possible
            (cons ,do
                  (cons (cons ,print terms)
                        (cons ,(print (char 10))
                              ())))))

(def comment
     ; add "(comment val)" to an expr head
     ; to substitute the expr with "val"
     (macro (terms) (car terms)))

(def log-runtime
     ; prints runtime (finish - start) of an expression
     ; usage: (log-runtime \'label\' (do something))
     (macro (terms)
            (let (-val (gensym))
              (quasiquote
                (do
                  (def start (time))
                  (def (unquote -val) (unquote (cadr terms)))
                  (println (+ \'Runtime for \' (unquote (car terms)) \':\')
                           (->string (* 1000 (- (time) start)))
                           \'ms\')
                  (unquote -val))))))

'
	'; string library, modeled after oak/libstr

(defn char-between? (c start end)
      (& (<= start c) (<= c end)))

(defn upper? (c)
      (char-between? c \'A\' \'Z\'))

(defn lower? (c)
      (char-between? c \'a\' \'z\'))

(defn digit? (c)
      (char-between? c \'0\' \'9\'))

(defn space? (c)
      (| (= c \' \')
         (= c \'\t\')
         (= c \'\n\')
         (= c \'\r\')
         (= c \'\f\')))

(defn letter? (c)
      (| (upper? c) (lower? c)))

(defn word? (c)
      (| (letter? c) (digit? c)))

(defn join (strings joiner)
      (do
        (default joiner \'\')
        (if (nil? strings)
          \'\'
          (do
            (defn -join (acc strings)
                  (if (nil? strings)
                    acc
                    (-join (+ acc joiner (car strings))
                           (cdr strings))))
            (-join (car strings) (cdr strings))))))

(defn starts-with? (s prefix)
      (= (gets s 0 (len prefix))
         prefix))

(defn ends-with? (s suffix)
      (= (gets s (- (len s) (len prefix)))
         suffix))

(defn str-index (s substr)
      (do
        (defn -iter (i)
              (if (<= (len s) i)
                -1
                (if (= (gets s i (+ i (len substr))) substr)
                  i
                  (-iter (inc i)))))
        (-iter 0)))

(defn str-contains? (s substr)
      (<= 0 (str-index s substr)))

(defn cut (s sep)
      (let (cut-at (str-index s sep))
        (list (gets s 0 cut-at)
              (gets s (+ cut-at (len sep))))))

; (defn upper)
; (defn lower)

(defn matches-at? (s substr i)
      (= (gets s i (+ i (len substr)))
         substr))

; (defn replace)
; (defn split)
; (defn pad-start)
; (defn pad-end)
; (defn trim-start)
; (defn trim-end)
; (defn trim)

'
	'; math library

; Euclid\'s GCD algorithm
(defn gcd (a b)
      ; prereq: a < b
      (do
        (defn sub (a b)
              (if (zero? a)
                b
                (sub (% b a) a)))
        (def a (abs a))
        (def b (abs b))
        (if (> a b)
          (sub b a)
          (sub a b))))

; LCM using GCD
(defn lcm (a b)
      (* a (/ b (gcd a b))))

(defn factor? (n c)
      (zero? (% n c)))

; prime filter
(defn prime? (n)
      (if (< n 2)
        false
        (do
          (def max (inc (int (sqrt n))))
          (defn sub (i)
                (if (= i max)
                  true
                  (if (factor? n i)
                    false
                    (sub (inc i)))))
          (sub 2))))

; prime factorize natural number
(defn prime-factors (n)
      (do
        (defn sub (pfs m pf)
              (if (= m 1)
                pfs
                (if (factor? m pf)
                  (sub (cons pf pfs)
                       (/ m pf)
                       pf)
                  (sub pfs
                       m
                       (inc pf)))))
        (reverse (sub () n 2))))

; naive factorize
(defn factors (n)
      (let (first-half (-> (nat (int (sqrt n)))
                           (filter (partial (factor? n _)))))
        (cond
          ((nil? first-half) first-half)
          ((nil? (cdr first-half)) first-half)
          (true
            (join first-half
                  (let (rev-first-half (reverse first-half))
                    (if (= (car rev-first-half)
                           (/ n (car rev-first-half)))
                      (cdr (map rev-first-half (partial (/ n _))))
                      (map rev-first-half (partial (/ n _))))))))))

(defn randi (max)
      (int (* (rand) max)))

(defn mean (xs)
      (/ (sum xs) (size xs)))
(def avg mean)

(defn geomean (xs)
      (# (prod xs) (/ 1 (size xs))))

'
	'; sort library, implementing quicksort

(defn sort! (xs pred)
      (do
        (default pred id)
        (def vpred (map xs pred))
        (defn partition (xs lo hi)
              (let (pivot (nth vpred lo))
                (do
                  (defn lsub (i)
                        (if (< (nth vpred i) pivot)
                          (lsub (inc i))
                          i))
                  (defn rsub (j)
                        (if (> (nth vpred j) pivot)
                          (rsub (dec j))
                          j))
                  (defn sub (i j)
                        (do
                          (def i (lsub i))
                          (def j (rsub j))
                          (if (< i j)
                            (do
                              (def tmp (nth xs i))
                              (def tmpPred (nth vpred i))
                              (nth! xs i (nth xs j))
                              (nth! xs j tmp)
                              (nth! vpred i (nth vpred j))
                              (nth! vpred j tmpPred)
                              (sub (inc i) (dec j)))
                            j)))
                  (sub lo hi))))
        (defn quicksort (xs lo hi)
              (if (| (< (size xs) 2)
                     (>= lo hi))
                xs
                (let (p (partition xs lo hi))
                  (do
                    (quicksort xs lo p)
                    (quicksort xs (inc p) hi)))))
        (quicksort xs 0 (dec (size xs)))))

(defn sort (xs pred)
      (-> (slice xs)
          (sort! pred)))

'
	'; random library, implementing utilities for working
; with pseudorandom sources of randomness

(defn rand-bool ()
      (< (rand) 0.5))

(defn rand-int (min max)
      (int (rand-number (int min)
                        (int max))))

(defn rand-number (min max)
      (do
        (when (nil? max)
          (do
            (def max min)
            (def min 0)))
        (+ min
           (* (rand) (- max min)))))

(defn rand-choice (xs)
      (nth xs
           (rand-int 0 (size xs))))

'
	'; utilities for writing tests

(defmacro run-tests (terms)
  (quasiquote
    (let (results (unquote (cons ,list terms)))
      (let (passed? cadr)
        (do
          (-> results
              (exclude passed?)
              (each (fn (r)
                        (let (name (car r))
                          (let (got (car (cddr r)))
                            (let (expected (cadr (cddr r)))
                              (println (+ name
                                          \': expected \'
                                          (->string expected)
                                          \', got \'
                                          (->string got)))))))))
          (println (+ (->string (-> results
                                    (filter passed?)
                                    size))
                      \'/\'
                      (->string (size results)))
                   \'tests passed.\'))))))

(defmacro test (terms)
  (do
    (def name (car terms))
    (def expected (cadr terms))
    (def body (car (cddr terms)))
    (quasiquote
      (let (got (unquote body))
        (list (unquote name)
              (= got (unquote expected)) ; result
              got (unquote expected))))))

'
], withEnv)

// CLI
with loadStdlib() fn(env) {
	lispFileIdx := if idx := args() |> find(fn(arg) arg |> endsWith?('.klisp') | arg |> endsWith?('.lisp')) {
		-1 -> default(2)
		_ -> idx
	}
	if path := args().(lispFileIdx) {
		? -> {
			println('Klisp interpreter v0.1-oak.')
			fn sub(env) {
				out('\x1b[0;33mλ\x1b[0;0m ') // ANSI yellow
				with input() fn(evt) if evt.type != :error -> {
					evt.data |>
						read() |>
						eval(env) |>
						print() |>
						println()
					sub(env)
				}
			}
			sub(env)
		}
		_ -> with fs.readFile(path) fn(file) if file {
			? -> println('error: could not read', path)
			_ -> file |> read() |> eval(env)
		}
	}
}

