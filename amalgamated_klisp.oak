#!/usr/bin/env oak

// A Klisp written in Oak
// ported over from the Ink implementation at thesephist/klisp.

{
	println: println
	default: default
	clone: clone
	slice: slice
	map: map
	find: find
	each: each
	reduce: reduce
	append: append
	entries: entries
	fromHex: fromHex
} := import('std')
{
	join: join
	replace: replace
	trim: trim
	endsWith?: endsWith?
} := import('str')
fs := import('fs')
path := import('path')

// alias print, because it will be overridden later
oakPrint := print

// Oak list -> Klisp list
fn listify(xs) {
	fn sub(acc, i) if i {
		-1 -> acc
		_ -> sub(
			[xs.(i), acc]
			i - 1
		)
	}
	sub(?, len(xs) - 1)
}

// Klisp list -> Oak list
fn unlistify(L) if L {
	? -> []
	_ -> append([L.0], unlistify(L.1))
}

// like std.map, but works on lisp lists
fn mapSexpr(L, f) {
	fn sub(mapped, rest) if rest {
		? -> mapped
		_ -> sub(mapped << f(rest.0), rest.1)
	}
	sub([], L) |> listify()
}

// like std.reduce, but works on lisp lists
fn reduceSexpr(L, init, f) {
	fn sub(acc, node) if node {
		? -> acc
		_ -> sub(f(acc, node.0), node.1)
	}
	sub(init, L)
}

fn Reader(s) {
	i := 0

	fn peek() s.(i)
	fn peekAhead(n) s.(i + n)
	fn next {
		c := peek()
		i <- i + 1
		c
	}
	fn nextSpan {
		fn sub(acc) if peek() {
			?, ' ', '\n', '\t', '(', ')' -> acc
			_ -> sub(acc << next())
		}
		sub('')
	}
	fn forward {
		fn sub() if peek() {
			' ', '\n', '\t' -> {
				next()
				sub()
			}
			// ignore comments
			';' -> {
				fn sub() if next() {
					? -> ?
					'\n' -> forward()
					_ -> sub()
				}
				sub()
			}
		}
		sub()
	}

	{
		peek: peek
		peekAhead: peekAhead
		next: next
		nextSpan: nextSpan
		forward: forward
	}
}

fn read(s) {
	r := Reader(s |> trim())

	{
		peek: peek
		peekAhead: peekAhead
		next: next
		nextSpan: nextSpan
		forward: forward
	} := r

	fn parse() if c := peek() {
		? -> { error: 'EOF' }
		')' -> { error: 'Unexpected )' }
		',' -> {
			next()
			forward()
			if type(result := parse()) {
				:object -> result
				_ -> [:quote, [result, ?]]
			}
		}
		'\'' -> {
			next()
			fn sub(acc) if peek() {
				? -> { error: 'EOF' }
				'\\' -> {
					next()
					sub(
						acc << if d := next() {
							't' -> '\t'
							'n' -> '\n'
							'r' -> '\r'
							'f' -> '\f'
							'x' -> {
								a := peek() |> default(' ')
								b := peekAhead(1) |> default(' ')
								maybeHexDigits := if hex := fromHex(a + b) {
									? -> 'x'
									_ -> {
										next()
										next()
										char(hex)
									}
								}
							}
							_ -> d
						}
					)
				}
				'\'' -> {
					next()
					forward()
					acc
				}
				_ -> sub(acc << next())
			}
			sub('')
		}
		'(' -> {
			next()
			forward()
			fn sub(acc, tail) if peek() {
				? -> { error: 'EOF' }
				')' -> {
					next()
					forward()
					acc
				}
				'.' -> {
					next()
					forward()
					if type(result := parse()) {
						:object -> result
						_ -> {
							cons := result
							forward()
							acc := if acc {
								? -> cons
								_ -> {
									tail.1 := cons
									acc
								}
							}
							sub(acc, cons)
						}
					}
				}
				_ -> if type(result := parse()) {
					:object -> result
					_ -> {
						cons := [result, ?]
						forward()
						acc := if acc {
							? -> cons
							_ -> {
								tail.1 := cons
								acc
							}
						}
						sub(acc, cons)
					}
				}
			}
			sub(?, ?)
		}
		_ -> {
			span := nextSpan()
			forward()
			if {
				? != x := int(span) -> x
				? != x := float(span) -> x
				span = '_' -> _
				_ -> atom(span)
			}
		}
	}

	// forward through possible space & comments at start
	forward()

	// if input is empty or comment-only, just eval to ()
	if peek() != ? -> {
		if type(result := parse()) {
			:object -> result
			_ -> {
				term := [result, ?]
				prog := [:do, term]
				forward()
				fn sub(tail) if peek() {
					? -> prog
					_ -> if type(result := parse()) {
						:object -> result
						_ -> {
							term := [result, ?]
							tail.1 := term
							forward()
							sub(term)
						}
					}
				}
				sub(term)
			}
		}
	}
}

fn must(result) if type(result) {
	:object -> {
		println(result.error)
		exit(1)
	}
	_ -> result
}

// globally unique sentinel values
LispNull := fn {}
LispEmpty := fn {}

fn getv(env, name, err?) if v := env.(name) {
	? -> if e := env.'\x00env' {
		? -> {
			if err? -> println('Unbound name "' + string(name) + '"')
			?
		}
		_ -> getv(e, name, err?)
	}
	LispNull -> ?
	LispEmpty -> _
	_ -> v
}

fn setv(env, name, v) if type(name) {
	:atom -> env.(name) := if type(v) {
		:null -> LispNull
		:empty -> LispEmpty
		_ -> v
	}
	:list -> {
		if v { ? -> v <- [] }
		setv(env, name.0, v.0)
		setv(env, name.1, v.1)
	}
}

fn getEnvMeta(env, metaKey) if im := env.(metaKey) {
	? -> if e := env.'\x00env' {
		? -> {
			println('No scope metadata "' + env.metaKey + '" found in env')
			exit(1)
		}
		_ -> getEnvMeta(e, metaKey)
	}
	_ -> im
}

fn getImportMap(env) getEnvMeta(env, '\x00importmap')
fn getEnvPath(env) getEnvMeta(env, '\x00path')

fn getImportEnv(importPath, env) {
	importMap := getImportMap(env)
	if cachedEnv := importMap.(importPath) {
		? -> {
			fs.readFile(importPath) |>
				read() |>
				must() |>
				eval(envi := { '\x00env': Env, '\x00path': path.dir(importPath) })
			importMap.(importPath) := envi
			envi
		}
		_ -> cachedEnv
	}
}

fn makeFn(f, L) [false, f, L]
fn makeMacro(f, L) [true, f, L]
fn makeNative(f) makeFn(f, ?)

fn eval(L, env) if type(L) {
	:atom -> getv(env, string(L), true)
	:list -> if L.0 {
		:def -> {
			name := L.(1).0
			val := eval(L.(1).(1).0, env)
			setv(env, name, val)
			val
		}
		:do -> {
			fn sub(form) if form.1 {
				? -> eval(form.0, env)
				_ -> {
					eval(form.0, env)
					sub(form.1)
				}
			}
			sub(L.1)
		}
		:if -> eval(
			if eval(L.(1).0, env) {
				true -> L.(1).(1).0
				_ -> L.(1).(1).(1).0
			}
			env
		)
		:fn -> {
			params := L.(1).0
			body := if L.(1).(1).1 {
				? -> L.(1).(1).0
				_ -> L.(1).(1).(1).0
			}
			makeFn(fn(args) eval(
				body
				{
					envc := { '\x00env': env }
					setv(envc, params, args)
					envc
				}
			), L)
		}
		:quote -> L.(1).0
		:macro -> {
			params := L.(1).0
			body := if L.(1).(1).1 {
				? -> L.(1).(1).0
				_ -> L.(1).(1).(1).0
			}
			makeMacro(fn(args) eval(
				body
				{
					envc := { '\x00env': env }
					setv(envc, params, args)
					envc
				}
			), L)
		}
		:expand -> {
			expr := eval(L.(1).0, env)
			if {
				expr = ? -> expr
				type(expr.0) = :atom -> if funcStub := getv(env, string(expr.0), false) {
					[_, _, _] -> if funcStub.0 {
						true -> eval(funcStub.1, env)(expr.1)
						_ -> expr
					}
					_ -> expr
				}
				_ -> expr
			}
		}
		:import -> {
			importPath := eval(L.(1).0, env)
			prefix := if L.(1).1 {
				? -> importPath
				_ -> eval(L.(1).(1).0, env)
			}
			path.resolve(importPath + '.klisp', getEnvPath(env)) |>
				getImportEnv(env) |>
				entries() |>
				each(fn(pair) if pair.0 != '\x00env' -> setv(env, atom(prefix + '/' + pair.0), pair.1))
		}
		_ -> {
			funcStub := eval(L.0, env)
			func := eval(funcStub.1, env)
			argcs := L.1

			if funcStub.0 { // reports whether the stub is a macro
				true -> func(argcs) |> eval(env)
				_ -> func(argcs |> mapSexpr(fn(x) eval(x, env)))
			}
		}
	}
	:string -> clone(L)
	_ -> L
}

Env := {
	// meta
	'\x00path': path.resolve('.')
	'\x00importmap': {}

	// constants
	'nil': LispNull
	'true': true
	'false': false

	// language primitives
	'car': makeNative(fn(L) if L.0 != ? -> L.(0).0)
	'cdr': makeNative(fn(L) if L.0 != ? -> L.(0).1)
	'car!': makeNative(fn(L) L.(0).0 := L.(1).0)
	'cdr!': makeNative(fn(L) L.(0).1 := L.(1).0)
	'cons': makeNative(fn(L) [L.0, L.(1).0])
	'len': makeNative(fn(L) if type(x := L.0) {
		:string -> len(x)
		:atom -> len(string(x))
		_ -> 0
	})
	'gets': makeNative(fn(L) if type(s := L.0) {
		:string -> slice(
			s
			if L.1 != ? -> int(L.(1).0)
			if L.1 != ? & L.(1).1 != ? -> int(L.(1).(1).0)
		)
		_ -> ''
	})
	'sets!': makeNative(fn(L) if type(s := L.0) {
		:string -> {
			idx := int(L.(1).0)
			s.(idx) := L.(1).(1).0
		}
		_ -> ''
	})
	'apply': makeNative(fn(L) {
		funcStub := L.0
		func := funcStub.1
		args := L.(1).0
		// can only apply a fn, not a macro
		if !funcStub.0 -> func(args)
	})
	'doc': makeNative(fn(L) {
		impl := L.(0).2
		if impl.(1).(1).1 != ? -> impl.(1).(1).0
	})

	// ports of Oak's builtins
	'char': makeNative(fn(L) char(int(L.0)))
	'codepoint': makeNative(fn(L) codepoint(L.0))
	'sin': makeNative(fn(L) sin(L.0))
	'cos': makeNative(fn(L) cos(L.0))
	'tan': makeNative(fn(L) tan(L.0))
	'asin': makeNative(fn(L) asin(L.0))
	'acos': makeNative(fn(L) acos(L.0))
	'atan': makeNative(fn(L) atan(L.0))
	'log': makeNative(fn(L) log(L.0, L.(1).0))
	'int': makeNative(fn(L) int(L.0))
	'float': makeNative(fn(L) float(L.0))
	'rand': makeNative(rand)
	'srand': makeNative(fn(L) srand(L.0))
	'time': makeNative(time)
	'nanotime': makeNative(nanotime)
	'wait': makeNative(fn(L) wait(float(L.0)))
	'exit': makeNative(fn(L) exit(int(L.0)))
	'args': makeNative(fn(_) {
		args() |> listify()
	})
	'env': makeNative(fn(_) {
		env() |> entries() |> listify()
	})
	'exec': makeNative(fn(L) {
		cmd := L.0
		argv := unlistify(L.(1).0)
		stdin := L.(1).(1).0
		exec(cmd, argv, stdin) |> entries() |> listify()
	})

	// arithmetic and logical operators
	'=': makeNative(fn(L) L.1 |> reduceSexpr(true, fn(acc, x) acc & L.0 = x))
	'<': makeNative(fn(L) if L {
		? -> true
		_ -> {
			last := L.0
			L.1 |> reduceSexpr(true, fn(acc, x) {
				y := acc & last < x
				last <- x
				y
			})
		}
	})
	'>': makeNative(fn(L) if L {
		? -> true
		_ -> {
			last := L.0
			L.1 |> reduceSexpr(true, fn(acc, x) {
				y := acc & last > x
				last <- x
				y
			})
		}
	})
	'<=': makeNative(fn(L) if L {
		? -> true
		_ -> {
			last := L.0
			L.1 |> reduceSexpr(true, fn(acc, x) {
				y := acc & last <= x
				last <- x
				y
			})
		}
	})
	'>=': makeNative(fn(L) if L {
		? -> true
		_ -> {
			last := L.0
			L.1 |> reduceSexpr(true, fn(acc, x) {
				y := acc & last >= x
				last <- x
				y
			})
		}
	})
	'+': makeNative(fn(L) L.1 |> reduceSexpr(L.0, fn(a, b) a + b))
	'-': makeNative(fn(L) L.1 |> reduceSexpr(L.0, fn(a, b) a - b))
	'*': makeNative(fn(L) L.1 |> reduceSexpr(L.0, fn(a, b) a * b))
	'/': makeNative(fn(L) L.1 |> reduceSexpr(L.0, fn(a, b) a / b))
	'%': makeNative(fn(L) L.1 |> reduceSexpr(L.0, fn(a, b) a % b))
	'#': makeNative(fn(L) L.1 |> reduceSexpr(L.0, pow))

	// types and conversions
	'type': makeNative(fn(L) if L.0 {
		[_, _, _] -> :function
		[_, _] -> :list
		_ -> if ty := type(L.0) {
			:null -> :nil
			:atom -> :symbol
			_ -> ty
		}
	})
	'string->int': makeNative(fn(L) int(L.0) |> default(0))
	'string->float': makeNative(fn(L) float(L.0) |> default(0))
	'string->symbol': makeNative(fn(L) atom(L.0))
	'->string': makeNative(fn(L) if type(x := L.0) {
		:string -> x
		_ -> print(L.0)
	})

	// I/O, system
	'input': makeNative(fn(_) {
		input() |> entries() |> listify()
	})
	'print': makeNative(fn(L) {
		output := L.1 |> reduceSexpr(
			if type(L.0) {
				:string -> L.0
				_ -> print(L.0)
			}
			fn(a, b) a + ' ' + if type(b) {
				:string -> b
				_ -> print(b)
			}
		)
		oakPrint(output)
	})
	'fs/read': makeNative(fn(L) if type(path := L.0) {
		:string -> fs.readFile(path)
		_ -> ?
	})
	'fs/write': makeNative(fn(L) if {
		type(path := L.0) = :string & type(file := L.(1).0) = :string ->
			fs.writeFile(path, file)
		_ -> ?
	})
	'fs/append': makeNative(fn(L) if {
		type(path := L.0) = :string & type(file := L.(1).0) = :string ->
			fs.appendFile(path, file)
		_ -> ?
	})
	'fs/stat': makeNative(fn(L) if type(path := L.0) {
		:string -> fs.statFile(path) |> entries() |> listify()
		_ -> ?
	})
	'fs/rm': makeNative(fn(L) if type(path := L.0) {
		:string -> rm(path)
		_ -> ?
	})
	'fs/ls': makeNative(fn(L) if type(path := L.0) {
		:string -> {
			fs.listFiles(path) |> map(fn(stat) {
				name := [:name, stat.name]
				len := [:len, stat.len]
				mod := [:mod, stat.mod]
				dir := [:dir, stat.dir]
				[name, [len, [mod, [dir, ?]]]]
			}) |> listify()
		}
		_ -> ?
	})
	'fs/mkdir': makeNative(fn(L) if type(path := L.0) {
		:string -> mkdir(path)
		_ -> ?
	})
	'listen': makeNative(fn(L) {
		// TODO: implement
	})
	'req': makeNative(fn(L) {
		// TODO: implement
	})

	// runtime
	'___runtime_gc': makeNative(___runtime_gc)
	'___runtime_mem': makeNative(fn(_) {
		___runtime_mem() |> entries() |> listify()
	})
	'___runtime_proc': makeNative(fn(_) {
		___runtime_proc() |> entries() |> listify()
	})
}

fn print(L) if type(L) {
	:null -> '()'
	:empty -> '_'
	:atom -> string(L)
	:string -> '\'' << (L |> replace('\\', '\\\\') |> replace('\'', '\\\'')) << '\''
	:list -> if L {
		[_, _] -> {
			fn sub(term, acc) if term {
				[_, [_, _]] -> sub(term.1, acc << print(term.0))
				[_, ?] -> acc << print(term.0)
				[_, _] -> sub(term.1, acc << print(term.0) << '.')
				_ -> acc << print(term)
			}
			'(' << join(sub(L, []), ' ') << ')'
		}
		[_, _, _] -> if L.2 {
			? -> '(function)'
			_ -> print(L.2)
		}
	}
	_ -> string(L)
}

fn loadLibSources(libs, withEnv) {
	fn sub(i, env) if i {
		len(libs) -> withEnv({ '\x00env': env })
		_ -> {
			file := libs.(i)
			file |> read() |> must() |> eval(env)
			sub(i + 1, env)
		}
	}
	// NOTE: core libraries are loaded into the root env
	sub(0, Env)
}

fn loadStdlib(withEnv) loadLibSources([
	// NOTE: when klisp.oak gets built, these placeholder strings are replaced
	// with the contents of the library source files by the build script.
	//
	// In the Ink-based Klisp CLI, this loading of libraries is asynchronous.
	'; core library

; cons cell shorthands
(def caar
  (fn (x) (car (car x))))
(def cadr
  (fn (x) (car (cdr x))))
(def cdar
  (fn (x) (cdr (car x))))
(def cddr
  (fn (x) (cdr (cdr x))))

; lazy-evaluating boolean combinators
(def !
  (fn (x)
    (if x false true)))
(def &
  (macro terms
    (if (= terms nil)
      ,true
      (cons ,if
            (cons (car terms)
                  (cons (cons ,& (cdr terms))
                        (cons ,false nil)))))))
(def |
  (macro terms
    (if (= terms nil)
      ,false
      (cons ,if
            (cons (car terms)
                  (cons ,true
                        (cons (cons ,| (cdr terms))
                              nil)))))))
(def ^
  (macro terms
    (cons ,!
          (cons (cons ,= terms)
                nil))))
(def != ^)
(def <<
  (fn (x y)
    (if (= (type x) ,string)
      (sets! x (len x) y)
      ; O(n^2) behavior with linked lists
      (do
        (def -<<
          (fn (x)
            (if (= x nil)
              (cons y nil)
              (cons (car x)
                    (-<< (cdr x) y)))))
        (-<< x y)))))

; type assertions
(def nil?
  (fn (x) (= x nil)))
(def zero?
  (fn (x) (= x 0)))
(def int?
  (fn (x) (= (type x) ,int)))
(def float?
  (fn (x) (= (type x) ,float)))
(def number?
  (fn (x) (| (int? x) (float? x))))
(def bool?
  (fn (x) (= (type x) ,bool)))
(def string?
  (fn (x) (= (type x) ,string)))
(def symbol?
  (fn (x) (= (type x) ,symbol)))
(def function?
  (fn (x) (= (type x) ,function)))
(def atom?
  (fn (x)
    (| (nil? x)
       (number? x)
       (bool? x)
       (string? x)
       (symbol? x)
       (function? x))))
(def cons?
  (fn (x)
    (= (type x) ,list)))
(def list?
  (fn (x)
    (| (= x nil)
       (= (type x) ,list))))

; identity
(def id
  (fn (x) x))
(def is
  (fn (x)
    (fn (y) (= x y))))
(def constantly
  (fn (x)
    (fn () x)))

; basic math
(def neg
  (fn (n) (- 0 n)))
(def pos?
  (fn (n) (> n 0)))
(def neg?
  (fn (n) (< n 0)))
(def not-pos?
  (fn (n) (<= n 0)))
(def not-neg?
  (fn (n) (>= n 0)))
(def abs
  (fn (n)
    (if (neg? n)
      (neg n)
      n)))
(def sign
  (fn (n)
    (if (neg? n) -1 1)))
(def sqrt
  (fn (n) (# n 0.5)))
(def even?
  (fn (n) (zero? (% n 2))))
(def odd?
  (fn (n) (zero? (% (+ n 1) 2))))
(def inc
  (fn (n) (+ n 1)))
(def dec
  (fn (n) (- n 1)))

; list methods
(def range
  (fn (start end step)
    (do
      (def -range
        (if (| (nil? step)
               (pos? step))
          (fn (start end step)
            (if (< start end)
              (cons start
                    (-range (+ start step) end step))
              nil))
          (fn (start end step)
            (if (> start end)
              (cons start
                    (-range (+ start step) end step))
              nil))))
      (if (nil? step)
        (if (nil? end)
          (-range 0 start 1)
          (-range start end 1))
        (-range start end step)))))

(def nat
  (fn (n) (range 1 (inc n))))

; async

(def interval
  (fn (duration f)
    (do
      (defn call-and-schedule-next (f last-call)
        (let
          (_ (f last-call))
          (time-to-next-call (- (+ last-call duration)
                                (time)))
          (if (pos? time-to-next-call)
            (do
              (wait time-to-next-call)
              (call-and-schedule-next f (+ last-call duration)))
            (call-and-schedule-next f (time)))))
      (call-and-schedule-next f (time)))))

'
	'; core macros

(def gensym
  (fn ()
    \'create a random, globally unique symbol\'
    (-> (rand)
        (* 100000000)
        int
        ->string
        ((fn (s) (+ \'sym\' s)))
        string->symbol)))

(def map-list
  (fn (xs f)
    \'a map implementation used for implementing macros, not meant to be used
    externally. For a supported "map" implementation, see map in lib/iter.\'
    (if (nil? xs)
      nil
      (cons (f (car xs))
            (map-list (cdr xs) f)))))

(def when
  (macro (cndn body)
    (list ,if cndn body nil)))

(def unless
  (macro (cndn body)
    (list ,if cndn nil body)))

(def let
  (macro terms
    (do
      (defn make-let ((declname declval) body)
        (list
          (list ,fn (list declname) body)
          declval))
      (defn expand-let (terms)
        (make-let
          (car terms)
          (if (nil? (cddr terms))
            (cadr terms)
            (expand-let (cdr terms)))))
      (expand-let terms))))

(def when-let
  (macro terms
    (quasiquote
      (let (unquote (car terms))
        (unless (nil? (unquote (caar terms)))
          (unquote (cadr terms)))))))

(def if-let
  (macro terms
    (do
      (def conddecl (car terms))
      (def condname (car conddecl))
      (def if-bodies (cdr terms))
      (def if-conseq (car if-bodies))
      (def if-altern (cadr if-bodies))
      (quasiquote
        (let (unquote conddecl)
          (if (! (nil? (unquote condname)))
            (unquote if-conseq)
            (unquote if-altern)))))))

(def list
  (macro items
    ((def -list
       (fn (items)
         (if (nil? items)
           nil
           (cons ,cons
                 (cons (car items)
                       (cons (-list (cdr items))
                             nil))))))
     items)))

(def quasiquote
  (macro terms
    (cons
      ,list
      (map-list (car terms)
                (fn (term)
                  (if (list? term)
                    (if (= ,unquote (car term))
                      (cadr term)
                      (list ,quasiquote term))
                    (list ,quote term)))))))

(def list-of
  (macro (n f)
    (quasiquote
      (-> (range (unquote n))
          (map-list (fn () (unquote f)))))))

(def do-times
  (macro (n body)
    (cons ,do
          (list-of n body))))

(def default
  (macro (name val)
    \'(default name value)\'
    (if (symbol? name)
      (quasiquote
        (if (= (unquote name) nil)
          (def (unquote name) (unquote val))
          (unquote name)))
      (quasiquote
        (if (= (unquote name) nil)
          (unquote val)
          (unquote name))))))

(def loop
  (macro (n body)
    \'(loop count body-with-break)\'
    (do
      (when (nil? body)
        (do
          (def body n)
          (def n -1)))
      (let (break-symb (gensym))
        (quasiquote
          (do
            (def broken-with (list nil))
            (defn loop-body (i break)
              (if (| (= i (unquote n))
                     (= (def ret (unquote body))
                        (quote (unquote break-symb))))
                (car broken-with)
                (loop-body (inc i) break)))
            (loop-body 0 (fn (ret)
                           (do
                             (car! broken-with ret)
                             (quote (unquote break-symb)))))))))))

(def while
  (macro (cndn . body)
    \'(while condition . body)\'
    (do
      (def -while-f (gensym))
      (quasiquote
        ((def (unquote -while-f)
           (fn ()
             (if (unquote cndn)
               (do
                 (unquote (cons ,do body))
                 ((unquote -while-f)))
               nil))))))))

(def defn
  (macro (name . rest)
    (quasiquote
      (def (unquote name)
        (unquote (cons (quote fn) rest))))))

(def defmacro
  (macro (name . rest)
    (quasiquote
      (def (unquote name)
        (unquote (cons (quote macro) rest))))))

(def cond
  (macro terms
    \'(cond (pred body) (pred body) (default-body))\'
    ((def -cond
       (fn (terms)
         (if (nil? terms)
           nil
           (if (nil? (cdar terms))
             (caar terms)
             (quasiquote
               (if (unquote (car (car terms)))
                 (unquote (cadr (car terms)))
                 (unquote (-cond (cdr terms)))))))))
     terms)))

(def cond-by
  (macro (pred name . branches)
    \'(cond-by pred value (target body) (target body) (default-body))\'
    (do
      (defn make-branch (br)
        (if (nil? (cdr br))
          br
          (let (target (car br))
            (body (cadr br))
            (list (list pred name target)
                  body))))
      (cons ,cond
            (map-list branches make-branch)))))

(def match
  (macro terms
    \'(match val (tag body) (tag body) (default-body))\'
    (do
      (def -match-val (gensym))
      (def -match
        (fn (terms)
          (if (nil? terms)
            nil
            (if (nil? (cdar terms))
              (caar terms)
              (quasiquote
                (if (= (unquote -match-val) (unquote (car (car terms))))
                  (unquote (cadr (car terms)))
                  (unquote (-match (cdr terms)))))))))
      (quasiquote
        (let ((unquote -match-val) (unquote (car terms)))
          (unquote (-match (cdr terms))))))))

(def ->
  (macro terms
    \'thread-first\'
    (do
      (def apply-partials
        (fn (partials expr)
          (if (nil? partials)
            expr
            (if (symbol? (car partials))
              (list (car partials)
                    (apply-partials (cdr partials) expr))
              (cons (caar partials)
                    (cons (apply-partials (cdr partials) expr)
                          (cdar partials)))))))
      (apply-partials (reverse (cdr terms))
                      (car terms)))))

(def ->>
  (macro terms
    \'thread-last\'
    (do
      (def apply-partials
        (fn (partials expr)
          (if (nil? partials)
            expr
            (if (symbol? (car partials))
              (list (car partials)
                    (apply-partials (cdr partials) expr))
              (<< (car partials)
                  (apply-partials (cdr partials) expr))))))
      (apply-partials (reverse (cdr terms))
                      (car terms)))))

(def as->
  (macro (name val . partials)
    \'thread-as: (as-> n 10 (double n) (sq (+ 10 n) 2))\'
    (do
      (defn replace-name (expr partial)
        (if (list? partial)
          (map-list partial
                    (fn (x)
                      (if (= x name)
                        expr
                        (replace-name expr x))))
          partial))
      (defn replace-partials (expr partials)
        (if (nil? partials)
          expr
          (replace-partials (replace-name expr (car partials))
                            (cdr partials))))
      (replace-partials val partials))))

(def partial
  (macro terms
    \'partial application\'
    (let (partial-arg (gensym))
      (list ,fn
            (list partial-arg)
            (do
              (defn -replace-partial-arg (expr)
                (if (list? expr)
                  (map-list expr -replace-partial-arg)
                  (if (= expr ,?)
                    partial-arg
                    expr)))
              (-replace-partial-arg terms))))))

(def macroexpand
  (macro terms
    \'macro expansion functions and macros\'
    (quasiquote (expand (quote (unquote (car terms)))))))

(def expand-all
  (fn (expr)
    (if (list? expr)
      (let (expanded (expand expr))
        (if (list? expanded)
          (if (= expr expanded)
            (map-list expanded expand-all)
            (expand-all expanded))
          expanded))
      expr)))

(def macroexpand-all
  (macro terms
    (quasiquote (expand-all (quote (unquote (car terms)))))))

; utilities

(def println
  (macro terms
    (if (nil? terms)
      ,(print \'\\n\')
      (cons ,do
            (cons (cons ,print terms)
                  (cons ,(print \'\\n\')
                        nil))))))

(def comment
  (macro terms
    \'add "(comment val)" to an expr head to substitute the expr with "val"\'
    (car terms)))

(def log-runtime
  (macro terms
    \'prints runtime (finish - start) of an expression
    usage: (log-runtime label (do something))\'
    (let (-val (gensym))
      (quasiquote
        (do
          (def start (time))
          (def (unquote -val) (unquote (cadr terms)))
          (println (+ \'Runtime for \' (unquote (car terms)) \':\')
                   (->string (* 1000 (- (time) start)))
                   \'ms\')
          (unquote -val))))))

'
	'; iterator and sequence functions

(defn base-iterator (seq)
  \'returns an empty string for strings, nil for lists\'
  (if (list? seq) nil \'\'))

(defn empty? (seq)
  \'reports whether a given iterable is empty\'
  (= seq (base-iterator seq)))

(defn first (seq)
  \'returns the first item of a given iterable, or the iterable\\\'s base iterator
  if the iterable is empty\'
  (if (list? seq)
    (car seq)
    (gets seq 0 1)))

(defn first! (seq x)
  \'mutates in place the first item of a given iterable\'
  (if (list? seq)
    (car! seq x)
    (sets! seq 0 x)))

(defn rest (seq)
  \'returns the rest (all items excluding the first) of a given iterable, or the
  iterable\\\'s base iterator if the iterable has one or fewer items\'
  (if (list? seq)
    (cdr seq)
    (gets seq 1)))

(defn rest! (seq xs)
  \'mutates in place everything except the first item of a given iterable\'
  (if (list? seq)
    (cdr! seq xs)
    (sets! seq 1 xs)))

(defn conj (x seq)
  \'conj(oin)s `x` onto the front of the iterable `seq`, producing a new seq\'
  (if (list? seq)
    (cons x seq)
    (+ x seq)))

; generic iterator implementations

(defn nth (xs i)
  \'returns the `i`th item of the iterable `xs`, or the base iterator of the
  iterable if there is not sufficient length\'
  (if (list? xs)
    (if (not-pos? i)
      (if (zero? i)
        (first xs)
        (base-iterator xs))
      (nth (rest xs) (dec i)))
    (gets xs i (inc i))))

(defn nth! (xs i x)
  \'mutates in place the `i`th item of the iterable `xs` to be `x`\'
  (if (list? xs)
    (if (not-pos? i)
      (first! xs x)
      (nth! (rest xs) (dec i) x))
    (sets! xs i (char-at x 0))))

(defn second (xs)
  \'returns the second item of an iterable; equivalent to (nth xs 1)\'
  (nth xs 1))

(defn last (xs)
  \'returns the last item of an iterable, or the base iterator if the iterable
  is empty\'
  (if (empty? xs)
    xs
    (if (empty? (rest xs))
      (first xs)
      (last (rest xs)))))

(defn index (xs x)
  \'returns the index at which `x` is first found in the iterable `xs`, or -1 if
  it cannot be found\'
  (do
    (defn index-from (xs x i)
      (if (empty? xs)
        -1
        (if (= (first xs) x)
          i
          (index-from (rest xs) x (inc i)))))
    (index-from xs x 0)))

(defn contains? (xs x)
  \'reports whether `x` is a member of the iterable `xs`\'
  (<= 0 (index xs x)))

(defn find (xs f?)
  \'returns the index at which `(f? x)` is true for some item `x` in the
  iterable `xs`, or -1 if no such item exists\'
  (do
    (defn find-from (xs f? i)
      (if (empty? xs)
        -1
        (if (f? (first xs))
          i
          (find-from (rest xs) f? (inc i)))))
    (find-from xs f? 0)))

(defn some? (xs f?)
  \'returns true if at least one item in the iterable `xs` satisfies the
  predicate `f?`. `f?` defaults to `id`\'
  (do
    (default f? id)
    (if (empty? xs)
      false
      (if (f? (first xs))
        true
        (some? (rest xs) f?)))))

(defn every? (xs f?)
  \'returns false if at least one item in the iterable `xs` does not satisfy the
  predicate `f?`. `f?` defaults to `id`\'
  (do
    (default f? id)
    (if (empty? xs)
      true
      (if (f? (first xs))
        (every? (rest xs) f?)
        false))))

(defn append xs
  \'join one or more iterables together\'
  (do
    (defn append-two (xs ys)
      (if (empty? xs)
        ys
        (conj (first xs)
              (append (rest xs) ys))))
    (reduce xs nil append-two)))

(defn reverse (xs)
  \'reverse the order of an iterable\'
  (do
    (defn -reverse (acc xs)
      (if (empty? xs)
        acc
        (-reverse (conj (first xs)
                        acc)
                  (rest xs))))
    (-reverse (base-iterator xs) xs)))

(defn enumerate (xs)
  \'return an iterable of pairs `(i x)` where `i` counts up from 0, and `x`
  comes from `xs`; resembles Python\\\'s enumerate() builtin\'
  (do
    (defn -enumerate (xs i)
      (if (empty? xs)
        nil
        (conj (list i (first xs))
              (-enumerate (rest xs) (+ i 1)))))
    (-enumerate xs 0)))

(defn map (xs f)
  \'return an iterable that results from applying `f` to each item in `xs`\'
  (if (empty? xs)
    xs
    (conj (f (first xs))
          (map (rest xs) f))))

(defn reduce (xs acc f)
  \'return the result of folding the iterable `xs` with the reducer `f`\'
  (if (empty? xs)
    acc
    (reduce (rest xs)
            (f acc (first xs))
            f)))

(defn filter (xs f?)
  \'return an iterable containing only the items from `xs` that satisfy the
  predicate `f?`\'
  (if (empty? xs)
    xs
    (if (f? (first xs))
      (conj (first xs)
            (filter (rest xs) f?))
      (filter (rest xs) f?))))

(defn exclude (xs f?)
  \'return an iterable containing only the items from `xs` that did not satisfy
  the predicate `f?`\'
  (if (empty? xs)
    xs
    (if (f? (first xs))
      (exclude (rest xs) f?)
      (conj (first xs)
            (exclude (rest xs) f?)))))

(defn separate (xs f?)
  \'sort elements of iterable `xs` into two different iterables depending on the
  result of the predicate `f?`\'
  (list (filter xs f?)
        (exclude xs f?)))

(defn each (xs f)
  \'apply the function `f` to each item in `xs`\'
  (unless (empty? xs)
    (do
      (f (first xs))
      (each (rest xs) f))))

(defn size (xs)
  \'return the number of items in the iterable `xs`\'
  (if (list? xs)
    (reduce xs 0 inc)
    (len xs)))

(defn take (xs n)
  \'return an iterable containing only the first `n` items of `xs`\'
  (let (n (max (list n 0)))
    (if (| (empty? xs) (zero? n))
      (base-iterator xs)
      (conj (first xs)
            (take (rest xs) (dec n))))))

(defn take-while (xs f?)
  \'return an iterable containing only the first consecutive items of `xs` that
  satisfy the predicate `f?`\'
  (if (empty? xs)
    xs
    (if (f? (first xs))
      (conj (first xs)
            (take-while (rest xs) f?))
      (base-iterator xs))))

(defn drop (xs n)
  \'return an iterable containing all items after the first `n` of `xs`\'
  (let (n (max (list n 0)))
    (if (| (empty? xs) (zero? n))
      xs
      (drop (rest xs) (dec n)))))

(defn drop-while (xs f?)
  \'return an iterable excluding the first consecutive items of `xs` that
  satisfy the predicate `f?`\'
  (if (empty? xs)
    xs
    (if (f? (first xs))
      (drop-while (rest xs) f?)
      xs)))

(defn slice (xs start end)
  \'return a sub-slice of the iterable `xs` from index `start` to `end`, which
  are 0 and `(size xs)` by default. For strings, this is equivalent to `gets`.\'
  (do
    (default start 0)
    (default end (size xs))
    (-> xs
        (drop start)
        (take (- end start)))))

(defn flatten (xs)
  \'given a list of iterables, return a new iterable resulting from joining
  together every iterable in the list\'
  (reduce xs (base-iterator (first xs)) append))

(defn zip (xs ys f)
  \'return an iterable whose nth item is the combination of nth items of `xs`
  and `ys`. By default, elements of the two iterables are combined using
  `list`, but this can be overridden using `f`.\'
  (do
    (default f (if (list? xs) list +))
    (if (| (empty? xs) (empty? ys))
      nil
      (cons (f (first xs) (first ys))
            (zip (rest xs) (rest ys) f)))))

(defn interleave (xs ys)
  \'given two iterables, return a new iterable where items appear first from
  `xs`, then `ys`, then `xs` again, and so on, interleaving items of each
  iterable\'
  (-> (zip xs ys) flatten))

(defn compact (xs)
  \'filter out nil values from the given list, returning a new list\'
  (exclude xs nil?))

(defn partition (xs by)
  \'partition the given iterable by either count or a predicate `by`, returning
  a list of iterables, each of the same type as `xs`\'
  (match (type by)
    (,nil (partition xs id))
    (,int (do
            (defn -partition (xs n)
              (let (tail (drop xs n))
                (if (empty? tail)
                  (list xs)
                  (conj (take xs n)
                        (-partition tail n)))))
            (-partition xs (if (< by 1) 1 by))))
    (,function (do
                 (defn cut-by (xs f)
                   (if (empty? xs)
                     (list (base-iterator xs) (base-iterator xs))
                     (let (first-half (conj (first xs)
                                            (take-while (rest xs)
                                                        (let (f-of-first (f (first xs)))
                                                          (fn (x) (= (f x) f-of-first))))))
                       (list first-half
                             (drop xs (size first-half))))))
                 (defn -partition (xs f)
                   (if (empty? xs)
                     nil
                     (do
                       (def cut (cut-by xs f))
                       (def first-half (car cut))
                       (def rest-half (cadr cut))
                       (cons first-half
                             (-partition rest-half f)))))
                 (-partition xs by)))))

(defn uniq (xs by)
  \'returns a list of unique items in `xs`, assuming a pre-sorted `xs`. This is
  analogous to the UNIX "sort" utility.\'
  (-> (partition xs by)
      (map first)))

'
	'; string library, modeled after oak/libstr

(defn char-at (s i)
  (gets s i (inc i)))

(defn char-between? (c start end)
  (& (<= start c) (<= c end)))

(defn upper? (c)
  (char-between? c \'A\' \'Z\'))

(defn lower? (c)
  (char-between? c \'a\' \'z\'))

(defn digit? (c)
  (char-between? c \'0\' \'9\'))

(defn space? (c)
  (| (= c \' \')
     (= c \'\\t\')
     (= c \'\\n\')
     (= c \'\\r\')
     (= c \'\\f\')))

(defn letter? (c)
  (| (upper? c) (lower? c)))

(defn word? (c)
  (| (letter? c) (digit? c)))

(defn join (strings joiner)
  (do
    (default joiner \'\')
    (if (nil? strings)
      \'\'
      (do
        (defn -join (acc strings)
          (if (nil? strings)
            acc
            (-join (+ acc joiner (car strings))
                   (cdr strings))))
        (-join (car strings) (cdr strings))))))

(defn str xs
  (-> xs (map ->string) join))

(defn starts-with? (s prefix)
  (= (gets s 0 (len prefix))
     prefix))

(defn ends-with? (s suffix)
  (= (gets s (- (len s) (len suffix)))
     suffix))

(defn str-index (s substr)
  (do
    (defn -iter (i)
      (if (<= (len s) i)
        -1
        (if (= (gets s i (+ i (len substr))) substr)
          i
          (-iter (inc i)))))
    (-iter 0)))

(defn str-contains? (s substr)
  (<= 0 (str-index s substr)))

(defn cut (s sep)
  (let (cut-at (str-index s sep))
    (list (gets s 0 cut-at)
          (gets s (+ cut-at (len sep))))))

(defn upper (s)
  (map s
       (fn (c)
         (if (lower? c)
           (char (- (codepoint c) 32))
           c))))

(defn lower (s)
  (map s
       (fn (c)
         (if (upper? c)
           (char (+ (codepoint c) 32))
           c))))

(defn matches-at? (s substr i)
  (= (gets s i (+ i (len substr)))
     substr))

(defn replace (s old new)
  (if (empty? old)
    s
    (do
      (def lnew (len new))
      (def lold (len old))
      (defn -replace (acc i)
        (if (matches-at? acc old i)
          (-replace (+ (gets acc 0 i)
                       new
                       (gets acc (+ i lold)))
                    (+ i lnew))
          (if (< i (len acc))
            (-replace acc (inc i))
            acc)))
      (-replace s 0))))

(defn split (s sep)
  (if (empty? sep)
    (reduce s (list) <<)
    (do
      (def lsep (len sep))
      (defn -split (coll i last)
        (if (matches-at? s sep i)
          (-split (<< coll (gets s last i))
                  (+ i lsep)
                  (+ i lsep))
          (if (< i (len s))
            (-split coll (inc i) last)
            (<< coll (gets s last)))))
      (-split (list) 0 0))))

(defn extend (pad n)
  (do
    (def times (int (/ n (len pad))))
    (def part (% n (len pad)))
    (defn -extend (base i)
      (if (zero? i)
        (<< base (gets pad 0 part))
        (-extend (<< base pad)
                 (dec i))))
    (-extend \'\' times)))

(defn pad-start (s n pad)
  (if (>= (len s) n)
    s
    (+ (extend pad (- n (len s)))
       s)))

(defn pad-end (s n pad)
  (if (>= (len s) n)
    s
    (+ s
       (extend pad (- n (len s))))))

(defn trim-start-space (s)
  (do
    (defn start (i)
      (if (space? (char-at s i))
        (start (inc i))
        i))
    (gets s (start 0))))

(defn trim-start-non-empty (s prefix)
  (do
    (def max (len s))
    (def lpref (len prefix))
    (defn -trim (i)
      (if (< i max)
        (if (matches-at? s prefix i)
          (-trim (+ i lpref))
          i)
        i))
    (gets s (-trim 0))))

(defn trim-start (s prefix)
  (match prefix
    (\'\' s)
    (nil (trim-start-space s))
    ((trim-start-non-empty s prefix))))

(defn trim-end-space (s)
  (do
    (defn end (i)
      (if (space? (char-at s i))
        (end (dec i))
        i))
    (gets s 0 (inc (end (dec (len s)))))))

(defn trim-end-non-empty (s suffix)
  (do
    (def lsuf (len suffix))
    (defn -trim (i)
      (if (> i -1)
        (if (matches-at? s suffix (- i lsuf))
          (-trim (- i lsuf))
          i)
        i))
    (gets s 0 (-trim (len s)))))

(defn trim-end (s suffix)
  (match suffix
    (\'\' s)
    (nil (trim-end-space s))
    ((trim-end-non-empty s suffix))))

(defn trim (s part)
  (-> s
      (trim-start part)
      (trim-end part)))

'
	'; mut: mutable storage of data

(defmacro defmut (name val)
  (quasiquote
    (def (unquote name) (cons (unquote val) nil))))

(defn getm (mut)
  (car mut))

(defn setm! (mut val)
  (car! mut val))

(defn incm! (mut val)
  (do
    (default val 1)
    (car! mut (+ (car mut) val))))

'
	'; math library

(def pi
  3.14159265358979323846264338327950288419716939937510)
(def π pi)

(def e
  2.71828182845904523536028747135266249775724709369995)

(defn // ns
  (int (apply / ns)))

(defn double (n)
  (+ n n))

(defn sq (n)
  (* n n))

(defn close? (n m epsilon)
  (< (abs (- n m))
     (default epsilon 0.00000001)))

(defn hypot (x0 y0 x1 y1)
  (do
    (default x1 0)
    (default y1 0)
    (sqrt (+ (sq (- x0 x1))
             (sq (- y0 y1))))))

(defn scale (x a b c d)
  (let (normed (/ (- x a) (- b a)))
    (if (& (nil? c) (nil? d))
      normed
      (+ c
         (* normed (- d c))))))

(defn bearing (x y d t)
  (list (+ x (* d (cos t)))
        (+ y (* d (sin t)))))

(defn orient (x0 y0 x1 y1)
  (let ((x y) (if (& (nil? x1)
                     (nil? y1))
                (list x0 y0)
                (list (- x1 x0)
                      (- y1 y0))))
    (cond ((pos? x)
           (* 2 (atan (/ y (+ x (hypot x y))))))
          ((& (<= x 0)
              (!= y 0))
           (* 2 (atan (/ (+ x (hypot x y)) y))))
          ((& (neg? x)
              (zero? y)))
          π)))

(def sum
  (fn (ns) (reduce ns 0 +)))

(def prod
  (fn (ns) (reduce ns 1 *)))

(def min
  (fn (xs)
    (if (nil? xs)
      nil
      (reduce xs
              (car xs)
              (fn (a b)
                (if (< a b) a b))))))

(def max
  (fn (xs)
    (if (nil? xs)
      nil
      (reduce xs
              (car xs)
              (fn (a b)
                (if (< a b) b a))))))

(defn clamp (x a b)
  (cond ((< x a) a)
        ((> x b) b)
        (x)))

(defn mean (xs)
  (/ (sum xs) (size xs)))

(defn geomean (xs)
  (# (prod xs) (/ 1 (size xs))))

(defn median (xs)
  (let
    (xs (sort xs))
    (count (size xs))
    (half (int (/ count 2)))
    (cond ((zero? count) nil)
          ((zero? (% count 2) (/ (+ (nth xs (dec half))
                                    (nth xs (half)))
                                 2)))
          ((nth xs half)))))

(defn stddev (xs)
  (let (xmean (mean xs))
    (when (nil? xmean)
      (-> xs
          (map (fn (x)
                 (sq (- xmean x))))
          mean
          sqrt))))

(defn round (n decimals)
  (do
    (default decimals 0)
    (if (< decimals 0)
      n
      (let (order (# 10 decimals))
        (if (>= n 0)
          (/ (int (+ (* n order) 0.5)) order)
          (neg (/ (int (+ (* (neg n) order) 0.5)) order)))))))

; Euclid\'s GCD algorithm
(defn gcd (a b)
  ; prereq: a < b
  (do
    (defn sub (a b)
      (if (zero? a)
        b
        (sub (% b a) a)))
    (def a (abs a))
    (def b (abs b))
    (if (> a b)
      (sub b a)
      (sub a b))))

; LCM using GCD
(defn lcm (a b)
  (* a (/ b (gcd a b))))

(defn factor? (n c)
  (zero? (% n c)))

; prime filter
(defn prime? (n)
  (if (< n 2)
    false
    (do
      (def max (inc (int (sqrt n))))
      (defn sub (i)
        (if (= i max)
          true
          (if (factor? n i)
            false
            (sub (inc i)))))
      (sub 2))))

; prime factorize natural number
(defn prime-factors (n)
  (do
    (defn sub (pfs m pf)
      (if (= m 1)
        pfs
        (if (factor? m pf)
          (sub (cons pf pfs)
               (/ m pf)
               pf)
          (sub pfs
               m
               (inc pf)))))
    (reverse (sub nil n 2))))

; naive factorize
(defn factors (n)
  (let (first-half (-> (nat (int (sqrt n)))
                       (filter (partial factor? n ?))))
    (cond
      ((nil? first-half) first-half)
      ((nil? (cdr first-half)) first-half)
      ((append first-half
               (let (rev-first-half (reverse first-half))
                 (if (= (car rev-first-half)
                        (/ n (car rev-first-half)))
                   (cdr (map rev-first-half (partial / n ?)))
                   (map rev-first-half (partial / n ?)))))))))

'
	'; sort library, implementing quicksort and mergesort

(defn merge (left right)
  (cond ((empty? left) right)
        ((empty? right) left)
        ((do
           (def l (first left))
           (def r (first right))
           (if (<= l r)
             (conj l (merge (rest left) right))
             (conj r (merge left (rest right))))))))

(defn mergesort (xs)
  (if (< (size xs) 2)
    xs
    (let (split-at (int (/ (size xs) 2)))
      (merge (mergesort (take xs split-at))
             (mergesort (drop xs split-at))))))

(defn quicksort (xs)
  (if (< (size xs) 2)
    xs
    (let (pivot (nth xs (int (/ (dec (size xs)) 2)))) ; heuristic: pick midpoint
      (-> (quicksort (filter xs (partial < ? pivot)))
          (append (filter xs (is pivot)))
          (append (quicksort (filter xs (partial > ? pivot))))))))

(defn sort! (xs pred)
  (do
    (default pred id)
    (def vpred (map xs pred))
    (defn containing-cons (xs i)
      (if (zero? i)
        xs
        (containing-cons (cdr xs) (dec i))))
    (if (list? xs)
      (defn swap (xs i j)
        (do
          (def ic (containing-cons xs i))
          (def jc (containing-cons xs j))
          (def tmp (car ic))
          (car! ic (car jc))
          (car! jc tmp)))
      (defn swap (xs i j)
        (do
          (def tmp (nth xs i))
          (nth! xs i (nth xs j))
          (nth! xs j tmp))))
    (defn partition (xs lo hi)
      (let (pivot (nth vpred lo))
        (do
          (defn lsub (i)
            (if (< (nth vpred i) pivot)
              (lsub (inc i))
              i))
          (defn rsub (j)
            (if (> (nth vpred j) pivot)
              (rsub (dec j))
              j))
          (defn sub (i j)
            (do
              (def i (lsub i))
              (def j (rsub j))
              (if (< i j)
                (do
                  (swap xs i j)
                  (swap vpred i j)
                  (sub (inc i) (dec j)))
                j)))
          (sub lo hi))))
    (defn quicksort (xs lo hi)
      (if (| (< (size xs) 2)
             (>= lo hi))
        xs
        (let (p (partition xs lo hi))
          (do
            (quicksort xs lo p)
            (quicksort xs (inc p) hi)))))
    (quicksort xs 0 (dec (size xs)))))

(defn sort (xs pred)
  (-> (slice xs)
      (sort! pred)))

'
	'; composites: persistent immutable associative arrays

(defmacro comp terms
  \'comps store key-value pairs in a list as
  ((key . value) (key . value) (key . value)) for O(n) lookup and O(1) insert.
  Each entry is a single cons cell rather than a list to make value lookup a
  bit more efficient.\'
  (do
    (def -comp
      (fn (items)
        (if (nil? items)
          nil
          (list ,cons
                (list ,cons (car items) (cadr items))
                (-comp (cddr items))))))
    (-comp terms)))

(defn comp? (x)
  (& (list? x)
     (every? x list?)))

(defn getc (cp k v)
  \'recursive value lookup by key\'
  (if (nil? cp)
    v
    (if (= k (caar cp))
      (cdar cp)
      (getc (cdr cp) k v))))

(defn setc (cp k v)
  \'comps are immutable, and new values are set by adding new entries to the
  head of the comp\\\'s underlying list. setc does not modify the given comp
  and returns a new comp with the new key, value set.\'
  (cons (cons k v)
        (exclude cp
                 (partial = k (car ?)))))

(defn keys (cp)
  \'get just the comp keys\'
  (map cp car))

(defn values (cp)
  \'get just the comp values\'
  (map cp cdr))

; functions with comps

(defn freq (xs)
  \'return a comp with frequency counts of each unique item in `xs`\'
  (reduce xs
          (comp)
          (fn (counts x)
            (setc counts
                  x
                  (inc (getc counts x 0))))))

'
	'; random library, implementing utilities for working
; with pseudorandom sources of randomness

(defn rand-bool ()
  \'returns a random bool with equal chance\'
  (< (rand) 0.5))

(defn rand-int (min max)
  \'returns a random integer in the range [min, max). If only a
  single number is given as the argument, the range is assumed
  to be [0, max) instead.\'
  (int (rand-number (int min)
                    (int max))))

(defn rand-number (min max)
  \'returns a random float in the range [min, max). If only a
  single number is given as the argument, the range is assumed
  to be [0, max) instead.\'
  (do
    (when (nil? max)
      (do
        (def max min)
        (def min 0)))
    (+ min
       (* (rand) (- max min)))))

(defn rand-choice (xs)
  \'returns a randomly picked item from the list xs\'
  (nth xs (rand-int 0 (size xs))))

(defn rand-normal ()
  (let
    (u (- 1 (rand)))
    (v (* 2 π (rand)))
    (* (sqrt (* -2 (log e u)))
       (cos v))))

(defn rand-alphanumeric (n)
  (-> (default n 1)
      (list-of (rand-choice \'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\'))
      join))

(defn uid ()
  (rand-alphanumeric 16))

'
	'; json library support for encoding/decoding JSON

(defn json/serialize (x)
  \'serialize a value `x` to a string\'
  (do
    (defn esc (c)
      (match c
        (\'\\t\' \'\\\\t\')
        (\'\\n\' \'\\\\n\')
        (\'\\r\' \'\\\\r\')
        (\'\\f\' \'\\\\f\')
        (\'"\' \'\\\\"\')
        (\'\\\\\' \'\\\\\\\\\')
        (c)))
    (defn escape (s)
      (do
        (def max (len s))
        (defn sub (i acc)
          (if (= i max)
            acc
            (sub (+ i 1) (<< acc (esc (char-at s i))))))
        (sub 0 \'\')))
    (match (type x)
      (,string (str \'"\' (escape x) \'"\'))
      (,symbol (str \'"\' (escape (str x)) \'"\'))
      (,int (str x))
      (,float (str x))
      (,bool (str x))
      (,list (if (comp? x)
              (str \'{\'
                     (-> x
                         (map (fn (cell)
                                (str \'"\'
                                  (escape (str (car cell)))
                                  \'":\'
                                     (json/serialize (cdr cell)))))
                         (join \',\'))
                     \'}\')
              (str \'[\'
                     (-> x
                         (map json/serialize)
                         (join \',\'))
                     \']\')))
      (\'null\'))))

(defn json/parse (s)
  \'parse out a value from the string `s`. Returns the symbol "error" instead on
  any syntax errors.\'
  (do
    (defn Reader (s)
      (do
        (defmut index 0)
        (defmut err? false)
        (defn next ()
          (incm! index)
          (default (char-at s (- (getm index) 1)) \'\'))
        (defn peek ()
          (default (char-at s (getm index)) \'\'))
        (defn next-word (n)
          (if (> (+ (getm index) n) (len s))
            (do
              (setm! index (len s))
              nil)
            (do
              (def idx (getm index))
              (def word (gets s idx (+ idx n)))
              (incm! index n)
              word)))
        ; fast-forward through whitespace
        (defn forward ()
          (do
            (defn -forward ()
              (when (space? (peek))
                (do
                  (incm! index)
                  (-forward))))
            (-forward)))
        (comp ,next next
              ,peek peek
              ,forward forward
              ,next-word next-word
              ,done? (fn ()
                       (>= (getm index (len s))))
              ,err! (fn ()
                      (do
                        (setm! err? true)
                        ,error))
              ,err? (fn () (getm err?)))))
    (defn parse-null (r)
      ())
    (defn parse-string (r)
      ())
    (defn parse-number (r)
      ())
    (defn parse-true (r)
      ())
    (defn parse-false (r)
      ())
    (defn parse-list (r)
      ())
    (defn parse-object (r)
      ())
    (defn -parse-reader (r)
      ())
    (-> s
        (Reader)
        (-parse-reader))))

'
	'; various data encodings: ascii

(defn bytes (s)
  (-> s split (map codepoint)))

(defn from-bytes (bs)
  (-> bs (map char) join))

(defn int->hex (n)
  (if (< n 16)
    (char-at \'0123456789abcdef\' n)
    (+ (int->hex (// n 16))
       (int->hex (% n 16)))))

(defn hex->int (s)
  (-> (range (len s))
      (map (fn (i)
             (* (# 16 i)
                (index \'0123456789abcdef\'
                       (char-at s (- (len s) i 1))))))
      sum
      int))

'
	'; utilities for working with dates and UNIX timestamps

(def leap-day (+ 31 28))
(def seconds-per-day 86400)
(def days-per-4-years (inc (* 4 365)))
(def days-per-100-years (dec (* 25 days-per-4-years)))
(def days-per-400-years (inc (* 4 days-per-100-years)))

; our zero time is the year 1 CE, though the Gregorian calendar doesn\'t extend
; that far into the past, to ensure that we can treat all dates in the Common
; Era correctly without going into negative integer division, and we can take
; advantage of 400-year cycles in the calendar.
(def zero-year 1)
(def days-from-1-to-1970 (- (* 5 days-per-400-years)
                            (* 31 365)
                            8)) ; 8 leap years

(def days-before-month
  (list
    _
    0
    31
    (+ 31 28)
    (+ 31 28 31)
    (+ 31 28 31 30)
    (+ 31 28 31 30 31)
    (+ 31 28 31 30 31 30)
    (+ 31 28 31 30 31 30 31)
    (+ 31 28 31 30 31 30 31 31)
    (+ 31 28 31 30 31 30 31 31 30)
    (+ 31 28 31 30 31 30 31 31 30 31)
    (+ 31 28 31 30 31 30 31 31 30 31 30)
    (+ 31 28 31 30 31 30 31 31 30 31 30 31)))

(defn datetime/leap-year? (year)
  (& (zero? (% year 4))
     (| (!= (% year 100) 0)
        (zero? (% year 400)))))

(defn datetime/describe-date (t)
  (do
    (def d (+ days-from-1-to-1970
              (// (- t (% t seconds-per-day))
                  seconds-per-day)))
    (when (& (neg? t)
             (!= (% t seconds-per-day) 0))
      (def d (dec d)))

    (def n400 (// d days-per-400-years))
    (def d (- d (* days-per-400-years n400)))

    (def n100 (// d days-per-100-years))
    (def n100 (- n100 (// n100 4)))
    (def d (- d (* days-per-100-years n100)))

    (def n4 (// d days-per-4-years))
    (def d (- d (* days-per-4-years n4)))

    (def n (// d 365))
    (def n (- n (// n 4)))
    (def d (- d (* 365 n)))

    (def year (+ zero-year
                 (* 400 n400)
                 (* 100 n100)
                 (* 4 n4)
                 n))
    (def month 0)
    (def day d)

    (def leap-year? (datetime/leap-year? year))
    (if (& leap-year?
           (= day leap-day))
      (def (month day) (list 2 29))
      (do
        (when (& leap-year?
                 (> day leap-day))
          (def day (dec day)))
        (defn sub-month (m)
          (if (< day (nth days-before-month (inc m)))
            m
            (sub-month (inc m))))
        (def month (sub-month 1))
        (def day (inc (- day (nth days-before-month month))))))
    (list year
          month
          day)))

(defn datetime/describe-clock (t)
  (do
    (def rem (% t seconds-per-day))
    (when (neg? rem)
      (def rem (+ rem seconds-per-day)))
    (let
      (hour (// rem 3600))
      (rem (% rem 3600))
      (minute (// rem 60))
      (list hour
            minute
            (% rem 60)))))

(defn datetime/describe (t)
  (append (datetime/describe-date t)
          (datetime/describe-clock t)))

(defn datetime/timestamp (desc)
  (let
    ((year month day hour minute second) desc)
    (leap-year? (datetime/leap-year? year))

    (year (- year zero-year))
    (n400 (// year 400))
    (year (% year 400))
    (n100 (// year 100))
    (year (% year 100))
    (n4 (// year 4))
    (year (% year 4))

    (days-year-to-date (if leap-year?
                         (cond
                           ((| (= month 1)
                               (& (= month 2)
                                  (< day 29)))
                            (dec (+ (nth days-before-month month) day)))
                           ((& (= month 2)
                               (= day 29))
                            59)
                           ((+ (nth days-before-month month) day)))
                         (dec (+ (nth days-before-month month) day))))
    (days-from-1 (+ (* days-per-400-years n400)
                    (* days-per-100-years n100)
                    (* days-per-4-years n4)
                    (* 365 year)
                    days-year-to-date))
    (days-from-1970 (- days-from-1
                       days-from-1-to-1970))
    (+ (* days-from-1970 seconds-per-day)
       (* 3600 hour)
       (* 60 minute)
       second)))

(defn datetime/format (t tz-offset)
  (do
    (default tz-offset 0)
    (def (year month day hour minute second)
      (datetime/describe (+ t (* 60 tz-offset))))
    (str (cond
           ((> year 9999) (-> year str (pad-start 6 \'0\')))
           ((neg? year) (str \'-\' (-> (neg year) str (pad-start 6 \'0\'))))
           ((-> year str (pad-start 4 \'0\'))))
         \'-\'
         (-> month str (pad-start 2 \'0\'))
         \'-\'
         (-> day str (pad-start 2 \'0\'))
         \'T\'
         (-> hour str (pad-start 2 \'0\'))
         \':\'
         (-> minute str (pad-start 2 \'0\'))
         \':\'
         (-> second int str (pad-start 2 \'0\'))
         (let (millis (round (% (* second 1000) 1000)))
           (if (zero? millis)
             \'\'
             (str \'.\' millis)))
         (cond
           ((zero? tz-offset) \'Z\')
           ((neg? tz-offset) (str (-> (// tz-offset 60) str (pad-start 2 \'0\'))
                                  \':\'
                                  (-> (% tz-offset 60) str (pad-start 2 \'0\'))))
           ((str \'-\'
                 (-> (// (neg tz-offset) 60) str (pad-start 2 \'0\'))
                 \':\'
                 (-> (% (neg tz-offset) 60) str (pad-start 2 \'0\'))))))))

(defn datetime/parse-tz-offset (offset-str)
  (let ((hh mm) (-> offset-str
                    (split \':\')
                    (map int)))
    (unless (| (nil? hh)
               (nil? mm))
      (+ (* 60 hh) mm))))

(defn datetime/parse (s)
  (let ((date clock) (split s \'T\'))
    (unless (| (nil? date)
               (nil? clock))
      (let
        ((year month day) (-> date
                              (split \'-\')
                              (map int)))
        ((hour minute second) (-> clock
                                  (take 8)
                                  (split \':\')
                                  (map int)))
        (unless (| (nil? year)
                   (nil? month)
                   (nil? day)
                   (nil? hour)
                   (nil? minute)
                   (nil? second))
          (let
            ((_ millis) (-> clock
                            (split \'.\')
                            (map (fn (s)
                                   (-> s (take 3) int)))))
            (tz-offset (cond
                         ((contains? clock \'+\')
                          (datetime/parse-tz-offset (slice clock
                                                           (inc (index clock \'+\')))))
                         ((contains? clock \'-\')
                          (let (parsed (datetime/parse-tz-offset (slice clock
                                                                        (inc (index clock \'-\')))))
                            (if (nil? parsed)
                              nil
                              (neg parsed))))
                         (0)))
            (unless (nil? tz-offset)
              (list year
                    month
                    day
                    hour
                    minute
                    (+ second (/ (default millis 0) 1000))
                    tz-offset))))))))



'
	'; working with UNIX style paths on file systems and in URIs

(defn path/abs? (path)
  (= (char-at path 0) \'/\'))

(defn path/rel? (path)
  (!= (char-at path 0) \'/\'))

(defn path/last-slash (path)
  (if (empty? path)
    0
    (do
      (defn -last-slash (i)
        (if (| ((nil? (nth path i)))
               (= \'/\' (nth path i)))
          i
          (-last-slash (dec i))))
      (-last-slash (dec (len path))))))

(defn path/dir (path)
  (let (path (trim-end path \'/\'))
    (-> path
        (slice 0 (path/last-slash path)))))

(defn path/base (path)
  (let (path (trim-end path \'/\'))
    (-> path
        (slice (inc (path/last-slash path))))))

(defn path/cut (path)
  (let
    (path (trim-end path \'/\'))
    (last-slash (path/last-slash path))
    (list (slice path 0 last-slash)
          (slice path (inc last-slash)))))

(defn path/clean (path)
  (let (cleaned (-> path
                    (split \'/\')
                    (reduce nil
                            (fn (parts part i)
                              (match part
                                (\'\' parts)
                                (\'.\' parts)
                                (\'..\' (if (zero? i)
                                        (<< parts part)
                                        (slice parts 0 (dec (size parts)))))
                                ((<< parts part)))))
                    (join \'/\')))
    (if (path/abs? path)
      (str \'/\' cleaned)
      cleaned)))

(defn path/join parts
  (-> parts
      (reduce \'\'
              (fn (base path)
                (if (empty? base)
                  path
                  (str base \'/\' path))))
      path/clean))

(defn path/split (path)
  (if (empty? (trim-end path \'/\'))
    nil
    (-> path
        (split \'/\')
        (exclude empty?))))

(defn path/resolve (path base)
  (if (path/abs? path)
    (path/clean path)
    (path/join (default base (getc (env) \'PWD\'))
               path)))

'
	'; utilities for writing and running test suites

(defn test/flatten-tree (test-tree)
  (-> test-tree
      (reduce (list)
              (fn (acc tree-node)
                (if (= ,test (car tree-node))
                  (<< acc tree-node)
                  (append acc (test/flatten-tree tree-node)))))))

(defn test/run (test-tree)
  (let
    (tests (test/flatten-tree test-tree))
    (tests-count (size tests))
    (clear-line (fn ()
                  \'\\x1b\\[2K\\x1b\\[0G\'))
    (name-test (fn (t)
                 (-> (nth t 1)
                     (join \' → \'))))
    (progress-bar (fn (i max-chars)
                    (let (bar (debug/bar (scale i
                                                0 tests-count
                                                0 max-chars)))
                      ; bar chars are 3 bytes per codepoint
                      (bar-len (-> bar len (/ 3) int))
                      (str bar
                           (extend \' \' (- max-chars bar-len))))))
    (passes (-> tests
                enumerate
                (filter (fn ((i t))
                          (let
                            (name (name-test t))
                            (n (inc i))
                            (_ (print
                                 (str (clear-line)
                                      \'[\' (progress-bar n 8) \'] (\' n \'/\' tests-count \') \' name)))
                            (result ((nth t 2)))
                            (expected ((nth t 3)))
                            (if (= result expected)
                              true
                              (do
                                (println
                                  (str (clear-line)
                                       name
                                       \': expected \' expected
                                       \', got \' result))
                                false)))))))
    (do
      (println (str (clear-line)
                    (if (= (size passes) tests-count)
                      \'all\'
                      (str (size passes) \'/\' tests-count))
                    \' tests passed.\'))
      (when (!= tests-count (size passes))
        (exit 1)))))

(defn test/make-test-group (name tests)
  (-> tests
      (map (fn (t)
             (do
               (nth! t 1
                     (cons name (nth t 1)))
               t)))))

(defn test/make-test (name body-fn expected-fn)
  (list ,test
        (list name)
        body-fn
        expected-fn))

(defmacro run-tests tests
  (list ,test/run
        (cons ,list tests)))

(defmacro deftestgroup (name . tests)
  (list ,test/make-test-group
        name
        (cons ,list tests)))

(defmacro deftest (name body expected)
  (quasiquote
    (test/make-test (unquote name)
                    (fn () (unquote body))
                    (fn () (unquote expected)))))

'
	'; utilities for debugging and inspecting runtime values

(defn debug/bar (n)
  (let
    (n (max (list (* 8 n) 0)))
    (whole (int (/ n 8)))
    (rem (% n 8))
    (graph (str (-> (range whole)
                    (map (constantly \'█\'))
                    (join))
                (match (round rem)
                  (0 \'\')
                  (1 \'▏\')
                  (2 \'▎\')
                  (3 \'▍\')
                  (4 \'▌\')
                  (5 \'▋\')
                  (6 \'▊\')
                  (7 \'▉\')
                  (8 \'█\'))))
    (if (& (empty? graph)
           (pos? n))
      \'▏\'
      graph)))



(defn debug/histo (xs bars cols)
  (if (zero? (size xs))
    \'\'
    (do
      (default bars (size xs))
      (default cols 80)
      (def xmin (min xs))
      (def xmax (max xs))
      (def unit (/ (- xmax xmin) bars))
      (def buckets (-> (range bars)
                       (map (fn (i)
                              (let
                                (lo (+ xmin (* unit i)))
                                (hi (+ lo unit))
                                (size (filter xs
                                              (fn (x)
                                                (& (>= x lo)
                                                   (< x hi))))))))))
      (def max-count (max buckets))
      (-> buckets
          (map (fn (n)
                 (-> n
                     (scale 0 max-count
                            0 cols)
                     debug/bar)))
          (join \'\\n\')))))

'
	'; cryptographic primitives and cryptographically safe sources of randomness

(defn uuid ()
  (do
    (def ns (-> (srand 16)
                (split)
                (map codepoint)))
    (sets! ns 6 (-> (gets ns 6)
                    (& 15)
                    (| 64)))
    (sets! ns 8 (-> (gets ns 8)
                    (& 63)
                    (| 128)))
    (defn x (b)
      (let (s (int->hex (nth ns b)))
        (if (= (len s) 1)
          (str 0 s)
          s)))
    (str (x 0) (x 1) (x 2) (x 3)
         \'-\'
         (x 4) (x 5)
         \'-\'
         (x 6) (x 7)
         \'-\'
         (x 8) (x 9)
         \'-\'
         (x 10) (x 11) (x 12) (x 13) (x 14) (x 15))))

'
	'; import macros

(defmacro import-from (symbol-path symbols)
  (cons
    ,do
    (cons
      (list ,import (str symbol-path))
      (-> (default symbols ())
          (map (fn (sym)
                 (list ,def sym (string->symbol (str symbol-path \'/\' sym)))))))))

(defmacro import-as (symbol-path alias)
  (quasiquote
    (import
      (unquote (str symbol-path))
      (unquote (str alias)))))

'
], withEnv)

// CLI
with loadStdlib() fn(env) {
	lispFileIdx := if idx := args() |> find(fn(arg) arg |> endsWith?('.klisp')) {
		-1 -> default(2)
		_ -> idx
	}
	if filePath := args().(lispFileIdx) {
		? -> {
			println('Klisp interpreter v0.1-oak.')
			incomplete := ''
			fn sub {
				if incomplete {
					'' -> 'λ '
					_ -> '  '
				} |> oakPrint()
				with input() fn(evt) if evt.type != :error -> {
					if evt.data |> trim() {
						'' -> ?
						';abort', '; abort' -> incomplete <- ''
						_ -> if type(result := read(incomplete + evt.data)) {
							:object -> if result.error {
								'EOF' -> incomplete << evt.data << '\n'
								_ -> println('Syntax error:', result.error)
							}
							_ -> {
								result |> eval(env) |> print() |> println()
								incomplete <- ''
							}
						}
					}
					sub()
				}
			}
			sub()
		}
		_ -> with fs.readFile(filePath) fn(file) if file {
			? -> println('error: could not read', filePath)
			_ -> file |> read() |> eval(env.'\x00path' := path.dir(filePath))
		}
	}
}

