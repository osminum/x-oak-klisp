#!/usr/bin/env oak

// A Klisp written in Oak
// ported over from the Ink implementation at thesephist/klisp.

{
	println: println
	default: default
	clone: clone
	slice: slice
	map: map
	find: find
	reduce: reduce
	fromHex: fromHex
} := import('std')
{
	join: join
	replace: replace
	trim: trim
	endsWith?: endsWith?
} := import('str')
fs := import('fs')

// alias print, because it will be overridden later
oakPrint := print

// Oak list -> Klisp list
fn listify(xs) {
	fn sub(acc, i) if i {
		-1 -> acc
		_ -> sub(
			[xs.(i), acc]
			i - 1
		)
	}
	sub(?, len(xs) - 1)
}

// like std.map, but works on lisp lists
fn mapSexpr(L, f) {
	fn sub(mapped, rest) if rest {
		? -> mapped
		_ -> sub(mapped << f(rest.0), rest.1)
	}
	sub([], L) |> listify()
}

// like std.reduce, but works on lisp lists
fn reduceSexpr(L, init, f) {
	fn sub(acc, node) if node {
		? -> acc
		_ -> sub(f(acc, node.0), node.1)
	}
	sub(init, L)
}

fn Reader(s) {
	i := 0

	fn peek() s.(i)
	fn peekAhead(n) s.(i + n)
	fn next {
		c := peek()
		i <- i + 1
		c
	}
	fn nextSpan {
		fn sub(acc) if peek() {
			?, ' ', '\n', '\t', '(', ')' -> acc
			_ -> sub(acc << next())
		}
		sub('')
	}
	fn forward {
		fn sub() if peek() {
			' ', '\n', '\t' -> {
				next()
				sub()
			}
			// ignore comments
			';' -> {
				fn sub() if next() {
					? -> ?
					'\n' -> forward()
					_ -> sub()
				}
				sub()
			}
		}
		sub()
	}

	{
		peek: peek
		peekAhead: peekAhead
		next: next
		nextSpan: nextSpan
		forward: forward
	}
}

fn read(s) {
	r := Reader(s |> trim())

	{
		peek: peek
		peekAhead: peekAhead
		next: next
		nextSpan: nextSpan
		forward: forward
	} := r

	fn parse() if c := peek() {
		? -> { error: 'EOF' }
		')' -> { error: 'Unexpected )' }
		',' -> {
			next()
			forward()
			if type(result := parse()) {
				:object -> result
				_ -> [:quote, [result, ?]]
			}
		}
		'\'' -> {
			next()
			fn sub(acc) if peek() {
				? -> { error: 'EOF' }
				'\\' -> {
					next()
					sub(
						acc << if d := next() {
							't' -> '\t'
							'n' -> '\n'
							'r' -> '\r'
							'f' -> '\f'
							'x' -> {
								a := peek() |> default(' ')
								b := peekAhead(1) |> default(' ')
								maybeHexDigits := if hex := fromHex(a + b) {
									? -> 'x'
									_ -> {
										next()
										next()
										char(hex)
									}
								}
							}
							_ -> d
						}
					)
				}
				'\'' -> {
					next()
					forward()
					acc
				}
				_ -> sub(acc << next())
			}
			sub('')
		}
		'(' -> {
			next()
			forward()
			fn sub(acc, tail) if peek() {
				? -> { error: 'EOF' }
				')' -> {
					next()
					forward()
					acc
				}
				'.' -> {
					next()
					forward()
					if type(result := parse()) {
						:object -> result
						_ -> {
							cons := result
							forward()
							acc := if acc {
								? -> cons
								_ -> {
									tail.1 := cons
									acc
								}
							}
							sub(acc, cons)
						}
					}
				}
				_ -> if type(result := parse()) {
					:object -> result
					_ -> {
						cons := [result, ?]
						forward()
						acc := if acc {
							? -> cons
							_ -> {
								tail.1 := cons
								acc
							}
						}
						sub(acc, cons)
					}
				}
			}
			sub(?, ?)
		}
		_ -> {
			span := nextSpan()
			forward()
			if {
				? != x := int(span) -> x
				? != x := float(span) -> x
				span = '_' -> _
				_ -> atom(span)
			}
		}
	}

	// forward through possible space & comments at start
	forward()

	// if input is empty or comment-only, just eval to ()
	if peek() != ? -> {
		if type(result := parse()) {
			:object -> result
			_ -> {
				term := [result, ?]
				prog := [:do, term]
				forward()
				fn sub(tail) if peek() {
					? -> prog
					_ -> if type(result := parse()) {
						:object -> result
						_ -> {
							term := [result, ?]
							tail.1 := term
							forward()
							sub(term)
						}
					}
				}
				sub(term)
			}
		}
	}
}

fn must(result) if type(result) {
	:object -> {
		println(result.error)
		exit(1)
	}
	_ -> result
}

// globally unique sentinel values
LispNull := fn {}
LispEmpty := fn {}

fn getv(env, name, err?) if v := env.(string(name)) {
	? -> if e := env.'\x00env' {
		? -> {
			if err? -> println('Unbound name "' + string(name) + '"')
			?
		}
		_ -> getv(e, string(name), err?)
	}
	LispNull -> ?
	LispEmpty -> _
	_ -> v
}

fn setv(env, name, v) env.(string(name)) := if type(v) {
	:null -> LispNull
	:empty -> LispEmpty
	_ -> v
}

fn makeFn(f, L) [false, f, L]
fn makeMacro(f, L) [true, f, L]
fn makeNative(f) makeFn(f, ?)

fn eval(L, env) if type(L) {
	:list -> if L.0 {
		:quote -> L.(1).0
		:def -> {
			name := L.(1).0
			val := eval(L.(1).(1).0, env)
			setv(env, name, val)
			val
		}
		:do -> {
			fn sub(form) if form.1 {
				? -> eval(form.0, env)
				_ -> {
					eval(form.0, env)
					sub(form.1)
				}
			}
			sub(L.1)
		}
		:if -> {
			cond := L.(1).0
			conseq := L.(1).(1).0
			altern := L.(1).(1).(1).0
			eval(
				if eval(cond, env) {
					true -> conseq
					_ -> altern
				}
				env
			)
		}
		:fn -> {
			params := L.(1).0
			body := if L.(1).(1).1 {
				? -> L.(1).(1).0
				_ -> L.(1).(1).(1).0
			}
			makeFn(fn(args) eval(
				body
				{
					envc := { '\x00env': env }
					fn setScope(param, arg) if type(param) {
						:atom -> setv(envc, param, arg)
						:list -> {
							if arg { ? -> arg <- [] }
							setScope(param.0, arg.0)
							setScope(param.1, arg.1)
						}
					}
					setScope(params, args)
					envc
				}
			), L)
		}
		:macro -> {
			params := L.(1).0
			body := if L.(1).(1).1 {
				? -> L.(1).(1).0
				_ -> L.(1).(1).(1).0
			}
			makeMacro(fn(args) eval(
				body
				{
					envc := { '\x00env': env }
					fn setScope(param, arg) if type(param) {
						:atom -> setv(envc, param, arg)
						:list -> {
							if arg { ? -> arg <- [] }
							setScope(param.0, arg.0)
							setScope(param.1, arg.1)
						}
					}
					setScope(params, args)
					envc
				}
			), L)
		}
		:expand -> {
			expr := eval(L.(1).0, env)
			if {
				expr = ? -> expr
				type(expr.0) = :atom -> if funcStub := getv(env, expr.0, false) {
					[_, _, _] -> if funcStub.0 {
						true -> eval(funcStub.1, env)(expr.1)
						_ -> expr
					}
					_ -> expr
				}
				_ -> expr
			}
		}
		_ -> {
			funcStub := eval(L.0, env)
			func := eval(funcStub.1, env)
			argcs := L.1

			// funcStub.0 reports whether the stub is a macro
			if funcStub.0 {
				true -> func(argcs) |> eval(env)
				_ -> func(argcs |> mapSexpr(fn(x) eval(x, env)))
			}
		}
	}
	:atom -> getv(env, L, true)
	:string -> clone(L)
	_ -> L
}

Env := {
	// constants
	'nil': LispNull
	'true': true
	'false': false

	// language primitives
	'car': makeNative(fn(L) if L.0 != ? -> L.(0).0)
	'cdr': makeNative(fn(L) if L.0 != ? -> L.(0).1)
	'car!': makeNative(fn(L) L.(0).0 := L.(1).0)
	'cdr!': makeNative(fn(L) L.(0).1 := L.(1).0)
	'cons': makeNative(fn(L) [L.0, L.(1).0])
	'len': makeNative(fn(L) if type(x := L.0) {
		:string -> len(x)
		:atom -> len(string(x))
		_ -> 0
	})
	'gets': makeNative(fn(L) if type(s := L.0) {
		:string -> slice(
			s
			if L.1 != ? -> int(L.(1).0)
			if L.1 != ? & L.(1).1 != ? -> int(L.(1).(1).0)
		)
		_ -> ''
	})
	'sets!': makeNative(fn(L) if type(s := L.0) {
		:string -> {
			idx := int(L.(1).0)
			s.(idx) := L.(1).(1).0
		}
		_ -> ''
	})
	'apply': makeNative(fn(L) {
		funcStub := L.0
		func := funcStub.1
		args := L.(1).0
		// can only apply a fn, not a macro
		if !funcStub.0 -> func(args)
	})
	'doc': makeNative(fn(L) {
		impl := L.(0).2
		if impl.(1).(1).1 != ? -> impl.(1).(1).0
	})

	// ports of Oak's builtins
	'char': makeNative(fn(L) char(int(L.0)))
	'codepoint': makeNative(fn(L) codepoint(L.0))
	'sin': makeNative(fn(L) sin(L.0))
	'cos': makeNative(fn(L) cos(L.0))
	'tan': makeNative(fn(L) tan(L.0))
	'int': makeNative(fn(L) int(L.0))
	'float': makeNative(fn(L) float(L.0))
	'rand': makeNative(rand)
	'time': makeNative(time)
	'nanotime': makeNative(nanotime)
	'wait': makeNative(fn(L) wait(float(L.0)))
	'exit': makeNative(fn(L) exit(int(L.0)))
	'args': makeNative(fn(_) {
		fn makeList(xs) if len(xs) {
			0 -> ?
			_ -> [xs.0, makeList(xs |> slice(1))]
		}
		makeList(args())
	})

	// arithmetic and logical operators
	'=': makeNative(fn(L) L.1 |> reduceSexpr(true, fn(acc, x) acc & L.0 = x))
	'<': makeNative(fn(L) if L {
		? -> true
		_ -> {
			last := L.0
			L.1 |> reduceSexpr(true, fn(acc, x) {
				y := acc & last < x
				last <- x
				y
			})
		}
	})
	'>': makeNative(fn(L) if L {
		? -> true
		_ -> {
			last := L.0
			L.1 |> reduceSexpr(true, fn(acc, x) {
				y := acc & last > x
				last <- x
				y
			})
		}
	})
	'<=': makeNative(fn(L) if L {
		? -> true
		_ -> {
			last := L.0
			L.1 |> reduceSexpr(true, fn(acc, x) {
				y := acc & last <= x
				last <- x
				y
			})
		}
	})
	'>=': makeNative(fn(L) if L {
		? -> true
		_ -> {
			last := L.0
			L.1 |> reduceSexpr(true, fn(acc, x) {
				y := acc & last >= x
				last <- x
				y
			})
		}
	})
	'+': makeNative(fn(L) L.1 |> reduceSexpr(L.0, fn(a, b) a + b))
	'-': makeNative(fn(L) L.1 |> reduceSexpr(L.0, fn(a, b) a - b))
	'*': makeNative(fn(L) L.1 |> reduceSexpr(L.0, fn(a, b) a * b))
	'/': makeNative(fn(L) L.1 |> reduceSexpr(L.0, fn(a, b) a / b))
	'%': makeNative(fn(L) L.1 |> reduceSexpr(L.0, fn(a, b) a % b))
	'#': makeNative(fn(L) L.1 |> reduceSexpr(L.0, pow))

	// types and conversions
	'type': makeNative(fn(L) if L.0 {
		[_, _, _] -> :function
		[_, _] -> :list
		_ -> if ty := type(L.0) {
			:null -> :nil
			:atom -> :symbol
			_ -> ty
		}
	})
	'string->int': makeNative(fn(L) int(L.0) |> default(0))
	'string->float': makeNative(fn(L) float(L.0) |> default(0))
	'string->symbol': makeNative(fn(L) atom(L.0))
	'->string': makeNative(fn(L) if type(x := L.0) {
		:string -> x
		_ -> print(L.0)
	})

	// I/O, system
	'print': makeNative(fn(L) {
		output := L.1 |> reduceSexpr(
			if type(L.0) {
				:string -> L.0
				_ -> print(L.0)
			}
			fn(a, b) a + ' ' + if type(b) {
				:string -> b
				_ -> print(b)
			}
		)
		oakPrint(output)
	})
	'read-file': makeNative(fn(L) if type(path := L.0) {
		:string -> fs.readFile(path)
		_ -> ?
	})
	'write-file': makeNative(fn(L) if {
		type(path := L.0) = :string & type(file := L.(1).0) = :string ->
			fs.writeFile(path, file)
		_ -> ?
	})
	'stat-file': makeNative(fn(L) if type(path := L.0) {
		:string -> {
			stat := fs.statFile(path)
			name := [:name, stat.name]
			len := [:len, stat.len]
			mod := [:mod, stat.mod]
			dir := [:dir, stat.dir]
			[name, [len, [mod, [dir, ?]]]]
		}
		_ -> ?
	})
	'list-files': makeNative(fn(L) if type(path := L.0) {
		:string -> {
			fs.listFiles(path) |> map(fn(stat) {
				name := [:name, stat.name]
				len := [:len, stat.len]
				mod := [:mod, stat.mod]
				dir := [:dir, stat.dir]
				[name, [len, [mod, [dir, ?]]]]
			}) |> listify()
		}
		_ -> ?
	})
}

fn print(L) if type(L) {
	:null -> '()'
	:empty -> '_'
	:atom -> string(L)
	:string -> '\'' << (L |> replace('\\', '\\\\') |> replace('\'', '\\\'')) << '\''
	:list -> if L {
		[_, _] -> {
			fn sub(term, acc) if term {
				[_, [_, _]] -> sub(term.1, acc << print(term.0))
				[_, ?] -> acc << print(term.0)
				[_, _] -> sub(term.1, acc << print(term.0) << '.')
				_ -> acc << print(term)
			}
			'(' << join(sub(L, []), ' ') << ')'
		}
		[_, _, _] -> if L.2 {
			? -> '(function)'
			_ -> print(L.2)
		}
	}
	_ -> string(L)
}

fn loadLibs(libs, withEnv) {
	fn sub(i, env) if i {
		len(libs) -> withEnv(env)
		_ -> with fs.readFile(libs.(i)) fn(file) {
			file |> read() |> must() |> eval(env)
			sub(i + 1, env)
		}
	}
	sub(0, Env |> clone())
}

fn loadLibSources(libs, withEnv) {
	fn sub(i, env) if i {
		len(libs) -> withEnv(env)
		_ -> {
			file := libs.(i)
			file |> read() |> must() |> eval(env)
			sub(i + 1, env)
		}
	}
	sub(0, Env |> clone())
}

fn loadStdlib(withEnv) loadLibSources([
	// NOTE: when klisp.oak gets built, these placeholder strings are replaced
	// with the contents of the library source files by the build script.
	//
	// In the Ink-based Klisp CLI, this loading of libraries is asynchronous.
	'; core library

; cons cell shorthands
(def caar
  (fn (x) (car (car x))))
(def cadr
  (fn (x) (car (cdr x))))
(def cdar
  (fn (x) (cdr (car x))))
(def cddr
  (fn (x) (cdr (cdr x))))

; lazy-evaluating boolean combinators
(def !
  (fn (x)
    (if x false true)))
(def &
  (macro terms
    (if (= terms nil)
      ,true
      (cons ,if
            (cons (car terms)
                  (cons (cons ,& (cdr terms))
                        (cons ,false nil)))))))
(def |
  (macro terms
    (if (= terms nil)
      ,false
      (cons ,if
            (cons (car terms)
                  (cons ,true
                        (cons (cons ,| (cdr terms))
                              nil)))))))
(def ^
  (macro terms
    (cons ,!
          (cons (cons ,= terms)
                nil))))
(def != ^)
(def <<
  (fn (x y)
    (if (= (type x) ,string)
      (sets! x (len x) y)
      ; O(n^2) behavior with linked lists
      (do
        (def -<<
          (fn (x)
            (if (= x nil)
              (cons y nil)
              (cons (car x)
                    (-<< (cdr x) y)))))
        (-<< x y)))))

; type assertions
(def nil?
  (fn (x) (= x nil)))
(def zero?
  (fn (x) (= x 0)))
(def int?
  (fn (x) (= (type x) ,int)))
(def float?
  (fn (x) (= (type x) ,float)))
(def number?
  (fn (x) (| (int? x) (float? x))))
(def bool?
  (fn (x) (= (type x) ,bool)))
(def string?
  (fn (x) (= (type x) ,string)))
(def symbol?
  (fn (x) (= (type x) ,symbol)))
(def function?
  (fn (x) (= (type x) ,function)))
(def list?
  (fn (x)
    (| (= x nil)
       (= (type x) ,list))))

; identity
(def id
  (fn (x) x))
(def is
  (fn (x)
    (fn (y) (= x y))))
(def constantly
  (fn (x)
    (fn () x)))

; basic math
(def neg
  (fn (n) (- 0 n)))
(def pos?
  (fn (n) (> n 0)))
(def neg?
  (fn (n) (< n 0)))
(def not-neg?
  (fn (n) (>= n 0)))
(def not-pos?
  (fn (n) (<= n 0)))
(def abs
  (fn (n)
    (if (neg? n)
      (neg n)
      n)))
(def sign
  (fn (n)
    (if (neg? n) -1 1)))
(def sqrt
  (fn (n) (# n 0.5)))
(def even?
  (fn (n) (zero? (% n 2))))
(def odd?
  (fn (n) (! (even? n))))
(def inc
  (fn (n) (+ n 1)))
(def dec
  (fn (n) (- n 1)))

; list methods
(def range
  (fn (start end step)
    (do
      (def -range
        (if (| (nil? step)
               (pos? step))
          (fn (start end step)
            (if (< start end)
              (cons start
                    (-range (+ start step) end step))
              nil))
          (fn (start end step)
            (if (> start end)
              (cons start
                    (-range (+ start step) end step))
              nil))))
      (if (nil? step)
        (if (nil? end)
          (-range 0 start 1)
          (-range start end 1))
        (-range start end step)))))

(def nat
  (fn (n) (range 1 (inc n))))

'
	'; core macros

(def gensym
  (fn ()
    \'create a random, globally unique symbol\'
    (-> (rand)
        (* 100000000)
        int
        ->string
        ((fn (s) (+ \'sym\' s)))
        string->symbol)))

(def map-list
  (fn (xs f)
    \'a map implementation used for implementing macros, not meant to be used
    externally. For a supported "map" implementation, see map in lib/iter.\'
    (if (nil? xs)
      nil
      (cons (f (car xs))
            (map-list (cdr xs) f)))))

(def when
  (macro (cndn body)
    (list ,if cndn body nil)))

(def unless
  (macro (cndn body)
    (list ,if cndn nil body)))

(def let
  (macro terms
    (do
      (defn make-let ((declname declval) body)
        (list
          (list ,fn (list declname) body)
          declval))
      (defn expand-let (terms)
        (make-let
          (car terms)
          (if (nil? (cddr terms))
            (cadr terms)
            (expand-let (cdr terms)))))
      (expand-let terms))))

(def when-let
  (macro terms
    (quasiquote
      (let (unquote (car terms))
        (unless (nil? (unquote (caar terms)))
          (unquote (cadr terms)))))))

(def if-let
  (macro terms
    (do
      (def conddecl (car terms))
      (def condname (car conddecl))
      (def if-bodies (cdr terms))
      (def if-conseq (car if-bodies))
      (def if-altern (cadr if-bodies))
      (quasiquote
        (let (unquote conddecl)
          (if (! (nil? (unquote condname)))
            (unquote if-conseq)
            (unquote if-altern)))))))

(def list
  (macro items
    ((def -list
       (fn (items)
         (if (nil? items)
           nil
           (cons ,cons
                 (cons (car items)
                       (cons (-list (cdr items))
                             nil))))))
     items)))

(def quasiquote
  (macro terms
    (cons
      ,list
      (map-list (car terms)
                (fn (term)
                  (if (list? term)
                    (if (= ,unquote (car term))
                      (cadr term)
                      (list ,quasiquote term))
                    (list ,quote term)))))))

(def list-of
  (macro (n f)
    (quasiquote
      (-> (range (unquote n))
          (map-list (fn () (unquote f)))))))

(def do-times
  (macro (n body)
    (cons ,do
          (list-of n body))))

(def default
  (macro (name val)
    \'(default name value)\'
    (quasiquote
      (if (= (unquote name) nil)
        (def (unquote name) (unquote val))
        (unquote name)))))

(def loop
  (macro (n body)
    \'(loop count body-with-break)\'
    (do
      (when (nil? body)
        (do
          (def body n)
          (def n -1)))
      (let (break-symb (gensym))
        (quasiquote
          (do
            (def broken-with (list nil))
            (defn loop-body (i break)
              (if (| (= i (unquote n))
                     (= (def ret (unquote body))
                        (quote (unquote break-symb))))
                (car broken-with)
                (loop-body (inc i) break)))
            (loop-body 0 (fn (ret)
                           (do
                             (car! broken-with ret)
                             (quote (unquote break-symb)))))))))))

(def while
  (macro (cndn . body)
    \'(while condition . body)\'
    (do
      (def -while-f (gensym))
      (quasiquote
        ((def (unquote -while-f)
           (fn ()
             (if (unquote cndn)
               (do
                 (unquote (cons ,do body))
                 ((unquote -while-f)))
               nil))))))))

(def defn
  (macro (name . rest)
    (quasiquote
      (def (unquote name)
        (unquote (cons (quote fn) rest))))))

(def defmacro
  (macro (name . rest)
    (quasiquote
      (def (unquote name)
        (unquote (cons (quote macro) rest))))))

(def cond
  (macro terms
    \'(cond (pred body) (pred body) (default-body))\'
    ((def -cond
       (fn (terms)
         (if (nil? terms)
           nil
           (if (nil? (cdar terms))
             (caar terms)
             (quasiquote
               (if (unquote (car (car terms)))
                 (unquote (cadr (car terms)))
                 (unquote (-cond (cdr terms)))))))))
     terms)))

(def cond-by
  (macro (pred name . branches)
    \'(cond-by pred value (target body) (target body) (default-body))\'
    (do
      (defn make-branch (br)
        (if (nil? (cdr br))
          br
          (let (target (car br))
            (body (cadr br))
            (list (list pred name target)
                  body))))
      (cons ,cond
            (map-list branches make-branch)))))

(def match
  (macro terms
    \'(match val (tag body) (tag body) (default-body))\'
    (do
      (def -match-val (gensym))
      (def -match
        (fn (terms)
          (if (nil? terms)
            nil
            (if (nil? (cdar terms))
              (caar terms)
              (quasiquote
                (if (= (unquote -match-val) (unquote (car (car terms))))
                  (unquote (cadr (car terms)))
                  (unquote (-match (cdr terms)))))))))
      (quasiquote
        (let ((unquote -match-val) (unquote (car terms)))
          (unquote (-match (cdr terms))))))))

(def ->
  (macro terms
    \'thread-first\'
    (do
      (def apply-partials
        (fn (partials expr)
          (if (nil? partials)
            expr
            (if (symbol? (car partials))
              (list (car partials)
                    (apply-partials (cdr partials) expr))
              (cons (caar partials)
                    (cons (apply-partials (cdr partials) expr)
                          (cdar partials)))))))
      (apply-partials (reverse (cdr terms))
                      (car terms)))))

(def ->>
  (macro terms
    \'thread-last\'
    (do
      (def apply-partials
        (fn (partials expr)
          (if (nil? partials)
            expr
            (if (symbol? (car partials))
              (list (car partials)
                    (apply-partials (cdr partials) expr))
              (<< (car partials)
                  (apply-partials (cdr partials) expr))))))
      (apply-partials (reverse (cdr terms))
                      (car terms)))))

(def as->
  (macro (name val . partials)
    \'thread-as: (as-> n 10 (double n) (sq (+ 10 n) 2))\'
    (do
      (defn replace-name (expr partial)
        (if (list? partial)
          (map-list partial
                    (fn (x)
                      (if (= x name)
                        expr
                        (replace-name expr x))))
          partial))
      (defn replace-partials (expr partials)
        (if (nil? partials)
          expr
          (replace-partials (replace-name expr (car partials))
                            (cdr partials))))
      (replace-partials val partials))))

(def partial
  (macro terms
    \'partial application\'
    (let (partial-arg (gensym))
      (list ,fn
            (list partial-arg)
            (do
              (defn -replace-partial-arg (expr)
                (if (list? expr)
                  (map-list expr -replace-partial-arg)
                  (if (= expr ,?)
                    partial-arg
                    expr)))
              (-replace-partial-arg terms))))))

(def macroexpand
  (macro terms
    \'macro expansion functions and macros\'
    (quasiquote (expand (quote (unquote (car terms)))))))

(def expand-all
  (fn (expr)
    (if (list? expr)
      (let (expanded (expand expr))
        (if (list? expanded)
          (if (= expr expanded)
            (map-list expanded expand-all)
            (expand-all expanded))
          expanded))
      expr)))

(def macroexpand-all
  (macro terms
    (quasiquote (expand-all (quote (unquote (car terms)))))))

; utilities

(def println
  (macro terms
    (cons ,do
          (cons (cons ,print terms)
                (cons ,(print \'\\n\')
                      nil)))))

(def comment
  (macro terms
    \'add "(comment val)" to an expr head to substitute the expr with "val"\'
    (car terms)))

(def log-runtime
  (macro terms
    \'prints runtime (finish - start) of an expression
    usage: (log-runtime label (do something))\'
    (let (-val (gensym))
      (quasiquote
        (do
          (def start (time))
          (def (unquote -val) (unquote (cadr terms)))
          (println (+ \'Runtime for \' (unquote (car terms)) \':\')
                   (->string (* 1000 (- (time) start)))
                   \'ms\')
          (unquote -val))))))

'
	'; iterator and sequence functions

(defn base-iterator (seq)
  \'returns an empty string for strings, nil for lists\'
  (if (list? seq) nil \'\'))

(defn empty? (seq)
  \'reports whether a given iterable is empty\'
  (= seq (base-iterator seq)))

(defn first (seq)
  \'returns the first item of a given iterable, or the iterable\\\'s base iterator
  if the iterable is empty\'
  (if (list? seq)
    (car seq)
    (gets seq 0 1)))

(defn first! (seq x)
  \'mutates in place the first item of a given iterable\'
  (if (list? seq)
    (car! seq x)
    (sets! seq 0 x)))

(defn rest (seq)
  \'returns the rest (all items excluding the first) of a given iterable, or the
  iterable\\\'s base iterator if the iterable has one or fewer items\'
  (if (list? seq)
    (cdr seq)
    (gets seq 1)))

(defn rest! (seq xs)
  \'mutates in place everything except the first item of a given iterable\'
  (if (list? seq)
    (cdr! seq xs)
    (sets! seq 1 xs)))

(defn conj (x seq)
  \'conj(oin)s `x` onto the front of the iterable `seq`, producing a new seq\'
  (if (list? seq)
    (cons x seq)
    (+ x seq)))

; generic iterator implementations

(defn nth (xs i)
  \'returns the `i`th item of the iterable `xs`, or the base iterator of the
  iterable if there is not sufficient length\'
  (if (list? xs)
    (if (not-pos? i)
      (if (zero? i)
        (first xs)
        (base-iterator xs))
      (nth (rest xs) (dec i)))
    (gets xs i (inc i))))

(defn nth! (xs i x)
  \'mutates in place the `i`th item of the iterable `xs` to be `x`\'
  (if (list? xs)
    (if (not-pos? i)
      (first! xs x)
      (nth! (rest xs) (dec i) x))
    (sets! xs i (char-at x 0))))

(defn second (xs)
  \'returns the second item of an iterable; equivalent to (nth xs 1)\'
  (nth xs 1))

(defn last (xs)
  \'returns the last item of an iterable, or the base iterator if the iterable
  is empty\'
  (if (empty? xs)
    xs
    (if (empty? (rest xs))
      (first xs)
      (last (rest xs)))))

(defn index (xs x)
  \'returns the index at which `x` is first found in the iterable `xs`, or -1 if
  it cannot be found\'
  (do
    (defn index-from (xs x i)
      (if (empty? xs)
        -1
        (if (= (first xs) x)
          i
          (index-from (rest xs) x (inc i)))))
    (index-from xs x 0)))

(defn contains? (xs x)
  \'reports whether `x` is a member of the iterable `xs`\'
  (<= 0 (index xs x)))

(defn find (xs f?)
  \'returns the index at which `(f? x)` is true for some item `x` in the
  iterable `xs`, or -1 if no such item exists\'
  (do
    (defn find-from (xs f? i)
      (if (empty? xs)
        -1
        (if (f? (first xs))
          i
          (find-from (rest xs) f? (inc i)))))
    (find-from xs f? 0)))

(defn some? (xs f?)
  \'returns true if at least one item in the iterable `xs` satisfies the
  predicate `f?`. `f?` defaults to `id`\'
  (do
    (default f? id)
    (if (empty? xs)
      false
      (if (f? (first xs))
        true
        (some? (rest xs) f?)))))

(defn every? (xs f?)
  \'returns false if at least one item in the iterable `xs` does not satisfy the
  predicate `f?`. `f?` defaults to `id`\'
  (do
    (default f? id)
    (if (empty? xs)
      true
      (if (f? (first xs))
        (every? (rest xs) f?)
        false))))

(defn append xs
  \'join one or more iterables together\'
  (do
    (defn append-two (xs ys)
      (if (empty? xs)
        ys
        (conj (first xs)
              (append (rest xs) ys))))
    (reduce xs nil append-two)))

(defn reverse (xs)
  \'reverse the order of an iterable\'
  (do
    (defn -reverse (acc xs)
      (if (empty? xs)
        acc
        (-reverse (conj (first xs)
                        acc)
                  (rest xs))))
    (-reverse (base-iterator xs) xs)))

(defn enumerate (xs)
  \'return an iterable of pairs `(i x)` where `i` counts up from 0, and `x`
  comes from `xs`; resembles Python\\\'s enumerate() builtin\'
  (do
    (defn -enumerate (xs i)
      (if (empty? xs)
        nil
        (conj (list i (first xs))
              (-enumerate (rest xs) (+ i 1)))))
    (-enumerate xs 0)))

(defn map (xs f)
  \'return an iterable that results from applying `f` to each item in `xs`\'
  (if (empty? xs)
    xs
    (conj (f (first xs))
          (map (rest xs) f))))

(defn reduce (xs acc f)
  \'return the result of folding the iterable `xs` with the reducer `f`\'
  (if (empty? xs)
    acc
    (reduce (rest xs)
            (f acc (first xs))
            f)))

(defn filter (xs f?)
  \'return an iterable containing only the items from `xs` that satisfy the
  predicate `f?`\'
  (if (empty? xs)
    xs
    (if (f? (first xs))
      (conj (first xs)
            (filter (rest xs) f?))
      (filter (rest xs) f?))))

(defn exclude (xs f?)
  \'return an iterable containing only the items from `xs` that did not satisfy
  the predicate `f?`\'
  (if (empty? xs)
    xs
    (if (f? (first xs))
      (exclude (rest xs) f?)
      (conj (first xs)
            (exclude (rest xs) f?)))))

(defn separate (xs f?)
  \'sort elements of iterable `xs` into two different iterables depending on the
  result of the predicate `f?`\'
  (list (filter xs f?)
        (exclude xs f?)))

(defn each (xs f)
  \'apply the function `f` to each item in `xs`\'
  (unless (empty? xs)
    (do
      (f (first xs))
      (each (rest xs) f))))

(defn size (xs)
  \'return the number of items in the iterable `xs`\'
  (if (list? xs)
    (reduce xs 0 inc)
    (len xs)))

(defn take (xs n)
  \'return an iterable containing only the first `n` items of `xs`\'
  (let (n (max (list n 0)))
    (if (| (empty? xs) (zero? n))
      (base-iterator xs)
      (conj (first xs)
            (take (rest xs) (dec n))))))

(defn take-while (xs f?)
  \'return an iterable containing only the first consecutive items of `xs` that
  satisfy the predicate `f?`\'
  (if (empty? xs)
    xs
    (if (f? (first xs))
      (conj (first xs)
            (take-while (rest xs) f?))
      (base-iterator xs))))

(defn drop (xs n)
  \'return an iterable containing all items after the first `n` of `xs`\'
  (let (n (max (list n 0)))
    (if (| (empty? xs) (zero? n))
      xs
      (drop (rest xs) (dec n)))))

(defn drop-while (xs f?)
  \'return an iterable excluding the first consecutive items of `xs` that
  satisfy the predicate `f?`\'
  (if (empty? xs)
    xs
    (if (f? (first xs))
      (drop-while (rest xs) f?)
      xs)))

(defn slice (xs start end)
  \'return a sub-slice of the iterable `xs` from index `start` to `end`, which
  are 0 and `(size xs)` by default. For strings, this is equivalent to `gets`.\'
  (do
    (default start 0)
    (default end (size xs))
    (-> xs
        (drop start)
        (take (- end start)))))

(defn flatten (xs)
  \'given a list of iterables, return a new iterable resulting from joining
  together every iterable in the list\'
  (reduce xs (base-iterator (first xs)) append))

(defn zip (xs ys f)
  \'return an iterable whose nth item is the combination of nth items of `xs`
  and `ys`. By default, elements of the two iterables are combined using
  `list`, but this can be overridden using `f`.\'
  (do
    (default f (if (list? xs) list +))
    (if (| (empty? xs) (empty? ys))
      nil
      (cons (f (first xs) (first ys))
            (zip (rest xs) (rest ys) f)))))

(defn interleave (xs ys)
  \'given two iterables, return a new iterable where items appear first from
  `xs`, then `ys`, then `xs` again, and so on, interleaving items of each
  iterable\'
  (-> (zip xs ys) flatten))

(defn compact (xs)
  \'filter out nil values from the given list, returning a new list\'
  (exclude xs nil?))

(defn partition (xs by)
  \'partition the given iterable by either count or a predicate `by`, returning
  a list of iterables, each of the same type as `xs`\'
  (match (type by)
    (,nil (partition xs id))
    (,int (do
            (defn -partition (xs n)
              (let (tail (drop xs n))
                (if (empty? tail)
                  (list xs)
                  (conj (take xs n)
                        (-partition tail n)))))
            (-partition xs (if (< by 1) 1 by))))
    (,function (do
                 (defn cut-by (xs f)
                   (if (empty? xs)
                     (list (base-iterator xs) (base-iterator xs))
                     (let (first-half (conj (first xs)
                                            (take-while (rest xs)
                                                        (let (f-of-first (f (first xs)))
                                                          (fn (x) (= (f x) f-of-first))))))
                       (list first-half
                             (drop xs (size first-half))))))
                 (defn -partition (xs f)
                   (if (empty? xs)
                     nil
                     (do
                       (def cut (cut-by xs f))
                       (def first-half (car cut))
                       (def rest-half (cadr cut))
                       (cons first-half
                             (-partition rest-half f)))))
                 (-partition xs by)))))

(defn uniq (xs by)
  \'returns a list of unique items in `xs`, assuming a pre-sorted `xs`. This is
  analogous to the UNIX "sort" utility.\'
  (-> (partition xs by)
      (map first)))

'
	'; string library, modeled after oak/libstr

(defn char-at (s i)
  (gets s i (inc i)))

(defn char-between? (c start end)
  (& (<= start c) (<= c end)))

(defn upper? (c)
  (char-between? c \'A\' \'Z\'))

(defn lower? (c)
  (char-between? c \'a\' \'z\'))

(defn digit? (c)
  (char-between? c \'0\' \'9\'))

(defn space? (c)
  (| (= c \' \')
     (= c \'\\t\')
     (= c \'\\n\')
     (= c \'\\r\')
     (= c \'\\f\')))

(defn letter? (c)
  (| (upper? c) (lower? c)))

(defn word? (c)
  (| (letter? c) (digit? c)))

(defn join (strings joiner)
  (do
    (default joiner \'\')
    (if (nil? strings)
      \'\'
      (do
        (defn -join (acc strings)
          (if (nil? strings)
            acc
            (-join (+ acc joiner (car strings))
                   (cdr strings))))
        (-join (car strings) (cdr strings))))))

(defn str xs
  (-> xs (map ->string) join))

(defn starts-with? (s prefix)
  (= (gets s 0 (len prefix))
     prefix))

(defn ends-with? (s suffix)
  (= (gets s (- (len s) (len suffix)))
     suffix))

(defn str-index (s substr)
  (do
    (defn -iter (i)
      (if (<= (len s) i)
        -1
        (if (= (gets s i (+ i (len substr))) substr)
          i
          (-iter (inc i)))))
    (-iter 0)))

(defn str-contains? (s substr)
  (<= 0 (str-index s substr)))

(defn cut (s sep)
  (let (cut-at (str-index s sep))
    (list (gets s 0 cut-at)
          (gets s (+ cut-at (len sep))))))

(defn upper (s)
  (map s
       (fn (c)
         (if (lower? c)
           (char (- (codepoint c) 32))
           c))))

(defn lower (s)
  (map s
       (fn (c)
         (if (upper? c)
           (char (+ (codepoint c) 32))
           c))))

(defn matches-at? (s substr i)
  (= (gets s i (+ i (len substr)))
     substr))

(defn replace (s old new)
  (if (empty? old)
    s
    (do
      (def lnew (len new))
      (def lold (len old))
      (defn -replace (acc i)
        (if (matches-at? acc old i)
          (-replace (+ (gets acc 0 i)
                       new
                       (gets acc (+ i lold)))
                    (+ i lnew))
          (if (< i (len acc))
            (-replace acc (inc i))
            acc)))
      (-replace s 0))))

(defn split (s sep)
  (if (empty? sep)
    (reduce s (list) <<)
    (do
      (def lsep (len sep))
      (defn -split (coll i last)
        (if (matches-at? s sep i)
          (-split (<< coll (gets s last i))
                  (+ i lsep)
                  (+ i lsep))
          (if (< i (len s))
            (-split coll (inc i) last)
            (<< coll (gets s last)))))
      (-split (list) 0 0))))

(defn extend (pad n)
  (do
    (def times (int (/ n (len pad))))
    (def part (% n (len pad)))
    (defn -extend (base i)
      (if (zero? i)
        (<< base (gets pad 0 part))
        (-extend (<< base pad)
                 (dec i))))
    (-extend \'\' times)))

(defn pad-start (s n pad)
  (if (>= (len s) n)
    s
    (+ (extend pad (- n (len s)))
       s)))

(defn pad-end (s n pad)
  (if (>= (len s) n)
    s
    (+ s
       (extend pad (- n (len s))))))

(defn trim-start-space (s)
  (do
    (defn start (i)
      (if (space? (char-at s i))
        (start (inc i))
        i))
    (gets s (start 0))))

(defn trim-start-non-empty (s prefix)
  (do
    (def max (len s))
    (def lpref (len prefix))
    (defn -trim (i)
      (if (< i max)
        (if (matches-at? s prefix i)
          (-trim (+ i lpref))
          i)
        i))
    (gets s (-trim 0))))

(defn trim-start (s prefix)
  (match prefix
    (\'\' s)
    (nil (trim-start-space s))
    ((trim-start-non-empty s prefix))))

(defn trim-end-space (s)
  (do
    (defn end (i)
      (if (space? (char-at s i))
        (end (dec i))
        i))
    (gets s 0 (inc (end (dec (len s)))))))

(defn trim-end-non-empty (s suffix)
  (do
    (def lsuf (len suffix))
    (defn -trim (i)
      (if (> i -1)
        (if (matches-at? s suffix (- i lsuf))
          (-trim (- i lsuf))
          i)
        i))
    (gets s 0 (-trim (len s)))))

(defn trim-end (s suffix)
  (match suffix
    (\'\' s)
    (nil (trim-end-space s))
    ((trim-end-non-empty s suffix))))

(defn trim (s part)
  (-> s
      (trim-start part)
      (trim-end part)))

'
	'; math library

(def pi
  3.14159265358979323846264338327950288419716939937510)
(def π pi)

(def e
  2.71828182845904523536028747135266249775724709369995)

(defn // ns
  (int (apply / ns)))

(defn double (n)
  (+ n n))

(defn sq (n)
  (* n n))

(defn hypot (x0 y0 x1 y1)
  (do
    (default x1 0)
    (default y1 0)
    (sqrt (+ (sq (- x0 x1))
             (sq (- y0 y1))))))

(defn scale (x a b c d)
  (let (normed (/ (- x a) (- b a)))
    (if (& (nil? c) (nil? d))
      normed
      (+ c
         (* normed (- d c))))))

(defn clamp (x a b)
  (cond ((< x a) a)
        ((> x b) b)
        (x)))

(defn round (n decimals)
  (do
    (default decimals 0)
    (if (< decimals 0)
      n
      (let (order (# 10 decimals))
        (if (>= n 0)
          (/ (int (+ (* n order) 0.5)) order)
          (neg (/ (int (+ (* (neg n) order) 0.5)) order)))))))

(defn even? (n)
  (zero? (% n 2)))

(defn odd? (n)
  (= (% n 2) 1))

; Euclid\'s GCD algorithm
(defn gcd (a b)
  ; prereq: a < b
  (do
    (defn sub (a b)
      (if (zero? a)
        b
        (sub (% b a) a)))
    (def a (abs a))
    (def b (abs b))
    (if (> a b)
      (sub b a)
      (sub a b))))

; LCM using GCD
(defn lcm (a b)
  (* a (/ b (gcd a b))))

(defn factor? (n c)
  (zero? (% n c)))

; prime filter
(defn prime? (n)
  (if (< n 2)
    false
    (do
      (def max (inc (int (sqrt n))))
      (defn sub (i)
        (if (= i max)
          true
          (if (factor? n i)
            false
            (sub (inc i)))))
      (sub 2))))

; prime factorize natural number
(defn prime-factors (n)
  (do
    (defn sub (pfs m pf)
      (if (= m 1)
        pfs
        (if (factor? m pf)
          (sub (cons pf pfs)
               (/ m pf)
               pf)
          (sub pfs
               m
               (inc pf)))))
    (reverse (sub nil n 2))))

; naive factorize
(defn factors (n)
  (let (first-half (-> (nat (int (sqrt n)))
                       (filter (partial factor? n ?))))
    (cond
      ((nil? first-half) first-half)
      ((nil? (cdr first-half)) first-half)
      ((append first-half
               (let (rev-first-half (reverse first-half))
                 (if (= (car rev-first-half)
                        (/ n (car rev-first-half)))
                   (cdr (map rev-first-half (partial / n ?)))
                   (map rev-first-half (partial / n ?)))))))))

(def sum
  (fn (ns) (reduce ns 0 +)))

(def prod
  (fn (ns) (reduce ns 1 *)))

(defn mean (xs)
  (/ (sum xs) (size xs)))

(defn geomean (xs)
  (# (prod xs) (/ 1 (size xs))))

(def min
  (fn (xs)
    (if (nil? xs)
      nil
      (reduce xs
              (car xs)
              (fn (a b)
                (if (< a b) a b))))))

(def max
  (fn (xs)
    (if (nil? xs)
      nil
      (reduce xs
              (car xs)
              (fn (a b)
                (if (< a b) b a))))))

'
	'; sort library, implementing quicksort and mergesort

(defn merge (left right)
  (cond ((empty? left) right)
        ((empty? right) left)
        ((do
           (def l (first left))
           (def r (first right))
           (if (<= l r)
             (conj l (merge (rest left) right))
             (conj r (merge left (rest right))))))))

(defn mergesort (xs)
  (if (< (size xs) 2)
    xs
    (let (split-at (int (/ (size xs) 2)))
      (merge (mergesort (take xs split-at))
             (mergesort (drop xs split-at))))))

(defn quicksort (xs)
  (if (< (size xs) 2)
    xs
    (let (pivot (nth xs (int (/ (dec (size xs)) 2)))) ; heuristic: pick midpoint
      (-> (quicksort (filter xs (partial < ? pivot)))
          (append (filter xs (is pivot)))
          (append (quicksort (filter xs (partial > ? pivot))))))))

(defn sort! (xs pred)
  (do
    (default pred id)
    (def vpred (map xs pred))
    (defn partition (xs lo hi)
      (let (pivot (nth vpred lo))
        (do
          (defn lsub (i)
            (if (< (nth vpred i) pivot)
              (lsub (inc i))
              i))
          (defn rsub (j)
            (if (> (nth vpred j) pivot)
              (rsub (dec j))
              j))
          (defn sub (i j)
            (do
              (def i (lsub i))
              (def j (rsub j))
              (if (< i j)
                (do
                  (def tmp (nth xs i))
                  (def tmpPred (nth vpred i))
                  (nth! xs i (nth xs j))
                  (nth! xs j tmp)
                  (nth! vpred i (nth vpred j))
                  (nth! vpred j tmpPred)
                  (sub (inc i) (dec j)))
                j)))
          (sub lo hi))))
    (defn quicksort (xs lo hi)
      (if (| (< (size xs) 2)
             (>= lo hi))
        xs
        (let (p (partition xs lo hi))
          (do
            (quicksort xs lo p)
            (quicksort xs (inc p) hi)))))
    (quicksort xs 0 (dec (size xs)))))

(defn sort (xs pred)
  (-> (slice xs)
      (sort! pred)))

'
	'; json library support for encoding/decoding JSON

(defn json/serialize (x)
  \'serialize a value `x` to a string\'
  (do
    (defn esc (c)
      (match c
        (\'\\t\' \'\\\\t\')
        (\'\\n\' \'\\\\n\')
        (\'\\r\' \'\\\\r\')
        (\'\\f\' \'\\\\f\')
        (\'"\' \'\\\\"\')
        (\'\\\\\' \'\\\\\\\\\')
        (c)))
    (defn escape (s)
      (do
        (def max (len s))
        (defn sub (i acc)
          (if (= i max)
            acc
            (sub (+ i 1) (<< acc (esc (char-at s i))))))
        (sub 0 \'\')))
    (match (type x)
      (,string (str \'"\' (escape x) \'"\'))
      (,symbol (str \'"\' (escape (str x)) \'"\'))
      (,int (str x))
      (,float (str x))
      (,bool (str x))
      (,list (if (comp? x)
             (str \'{\'
                  (-> x
                      (map (fn (cell)
                             (str \'"\'
                                  (escape (str (car cell)))
                                  \'":\'
                                  (json/serialize (cdr cell)))))
                      (join \',\'))
                  \'}\')
             (str \'[\'
                  (-> x
                      (map json/serialize)
                      (join \',\'))
                  \']\')))
      (\'null\'))))

(defn json/parse (s)
  \'parse out a value from the string `s`. Returns the symbol "error" instead on
  any syntax errors.\'
  (do
    (defn Reader (s)
      (do
        (defmut index 0)
        (defmut err? false)
        (defn next ()
          (incm! index)
          (default (char-at s (- (getm index) 1)) \'\'))
        (defn peek ()
          (default (char-at s (getm index)) \'\'))
        (defn next-word (n)
          (if (> (+ (getm index) n) (len s))
            (do
              (setm! index (len s))
              nil)
            (do
              (def idx (getm index))
              (def word (gets s idx (+ idx n)))
              (incm! index n)
              word)))
        ; fast-forward through whitespace
        (defn forward ()
          (do
            (defn -forward ()
              (when (space? (peek))
                (do
                  (incm! index)
                  (-forward))))
            (-forward)))
        (comp ,next next
              ,peek peek
              ,forward forward
              ,next-word next-word
              ,done? (fn ()
                       (>= (getm index (len s))))
              ,err! (fn ()
                      (do
                        (setm! err? true)
                        ,error))
              ,err? (fn () (getm err?)))))
    (defn parse-null (r)
      ())
    (defn parse-string (r)
      ())
    (defn parse-number (r)
      ())
    (defn parse-true (r)
      ())
    (defn parse-false (r)
      ())
    (defn parse-list (r)
      ())
    (defn parse-object (r)
      ())
    (defn -parse-reader (r)
      ())
    (-> s
        (Reader)
        (-parse-reader))))

'
	'; random library, implementing utilities for working
; with pseudorandom sources of randomness

(defn rand-bool ()
  \'returns a random bool with equal chance\'
  (< (rand) 0.5))

(defn rand-int (min max)
  \'returns a random integer in the range [min, max). If only a
  single number is given as the argument, the range is assumed
  to be [0, max) instead.\'
  (int (rand-number (int min)
                    (int max))))

(defn rand-number (min max)
  \'returns a random float in the range [min, max). If only a
  single number is given as the argument, the range is assumed
  to be [0, max) instead.\'
  (do
    (when (nil? max)
      (do
        (def max min)
        (def min 0)))
    (+ min
       (* (rand) (- max min)))))

(defn rand-choice (xs)
  \'returns a randomly picked item from the list xs\'
  (nth xs (rand-int 0 (size xs))))

(defn rand-alphanumeric (n)
  (-> (default n 1)
      (list-of (rand-choice \'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\'))
      join))

(defn uid ()
  (rand-alphanumeric 16))

'
	'; various data encodings: ascii

(defn bytes (s)
  (-> s split (map codepoint)))

(defn from-bytes (bs)
  (-> bs (map char) join))

(defn int->hex (n)
  (if (< n 16)
    (char-at \'0123456789abcdef\' n)
    (+ (int->hex (// n 16))
       (int->hex (% n 16)))))

(defn hex->int (s)
  (-> (range (len s))
      (map (fn (i)
             (* (# 16 i)
                (index \'0123456789abcdef\'
                       (char-at s (- (len s) i 1))))))
      sum
      int))

'
	'; composites: persistent immutable associative arrays

(defmacro comp terms
  \'comps store key-value pairs in a list as
  ((key . value) (key . value) (key . value)) for O(n) lookup and O(1) insert.
  Each entry is a single cons cell rather than a list to make value lookup a
  bit more efficient.\'
  (do
    (def -comp
      (fn (items)
        (if (nil? items)
          nil
          (list ,cons
                (list ,cons (car items) (cadr items))
                (-comp (cddr items))))))
    (-comp terms)))

(defn comp? (x)
  (& (list? x)
     (every? x list?)))

(defn getc (cp k v)
  \'recursive value lookup by key\'
  (if (nil? cp)
    v
    (if (= k (caar cp))
      (cdar cp)
      (getc (cdr cp) k v))))

(defn setc (cp k v)
  \'comps are immutable, and new values are set by adding new entries to the
  head of the comp\\\'s underlying list. setc does not modify the given comp
  and returns a new comp with the new key, value set.\'
  (cons (cons k v)
        (exclude cp
                 (partial = k (car ?)))))

(defn keys (cp)
  \'get just the comp keys\'
  (map cp car))

(defn values (cp)
  \'get just the comp values\'
  (map cp cdr))

; functions with comps

(defn freq (xs)
  \'return a comp with frequency counts of each unique item in `xs`\'
  (reduce xs
          (comp)
          (fn (counts x)
            (setc counts
                  x
                  (inc (getc counts x 0))))))

'
	'; mut: mutable storage of data

(defmacro defmut (name val)
  (quasiquote
    (def (unquote name) (cons (unquote val) nil))))

(defn getm (mut)
  (car mut))

(defn setm! (mut val)
  (car! mut val))

(defn incm! (mut val)
  (do
    (default val 1)
    (car! mut (+ (car mut) val))))

'
	'; utilities for writing and running test suites

(defn test/flatten-tree (test-tree)
  (-> test-tree
      (reduce (list)
              (fn (acc tree-node)
                (if (= ,test (car tree-node))
                  (<< acc tree-node)
                  (append acc (test/flatten-tree tree-node)))))))

(defn test/run (test-tree)
  (let
    (tests (test/flatten-tree test-tree))
    (tests-count (size tests))
    (clear-line! (fn ()
                   (print \'\\x1b[2K\\x1b[0G\')))
    (name-test (fn (t)
                 (-> (nth t 1)
                     (join \' → \'))))
    (passes (-> tests
                (enumerate)
                (filter (fn ((i t))
                          (let
                            (name (name-test t))
                            (do
                              ; pre-compute log-line so there is no delay
                              ; between clear-line! and logging the test name
                              (def log-line (str \'(\' (inc i) \'/\' tests-count \')\'
                                                 \' \'
                                                 name))
                              (clear-line!)
                              (print log-line)
                              (def result ((nth t 2)))
                              (def expected ((nth t 3)))
                              (if (= result expected)
                                true
                                (do
                                  (clear-line!)
                                  (println (str name
                                                \': expected \' expected
                                                \', got \' result))
                                  false))))))))
    (do
      (clear-line!)
      (println (str (size passes) \'/\' tests-count
                    \' tests passed.\'))
      (when (!= tests-count (size passes))
        (exit 1)))))

(defn test/make-test-group (name tests)
  (-> tests
      (map (fn (t)
             (do
               (nth! t 1
                     (cons name (nth t 1)))
               t)))))

(defn test/make-test (name body-fn expected-fn)
  (list ,test
        (list name)
        body-fn
        expected-fn))

(defmacro run-tests tests
  (list ,test/run
        (cons ,list tests)))

(defmacro deftestgroup (name . tests)
  (list ,test/make-test-group
        name
        (cons ,list tests)))

(defmacro deftest (name body expected)
  (quasiquote
    (test/make-test (unquote name)
                    (fn () (unquote body))
                    (fn () (unquote expected)))))

'
], withEnv)

// CLI
with loadStdlib() fn(env) {
	lispFileIdx := if idx := args() |> find(fn(arg) arg |> endsWith?('.klisp') | arg |> endsWith?('.lisp')) {
		-1 -> default(2)
		_ -> idx
	}
	if path := args().(lispFileIdx) {
		? -> {
			println('Klisp interpreter v0.1-oak.')
			incomplete := ''
			fn sub {
				if incomplete {
					'' -> 'λ '
					_ -> '  '
				} |> oakPrint()
				with input() fn(evt) if evt.type != :error -> {
					if evt.data |> trim() {
						'' -> ?
						';abort', '; abort' -> incomplete <- ''
						_ -> if type(result := read(incomplete + evt.data)) {
							:object -> if result.error {
								'EOF' -> incomplete << evt.data << '\n'
								_ -> println('Syntax error:', result.error)
							}
							_ -> {
								result |> eval(env) |> print() |> println()
								incomplete <- ''
							}
						}
					}
					sub()
				}
			}
			sub()
		}
		_ -> with fs.readFile(path) fn(file) if file {
			? -> println('error: could not read', path)
			_ -> file |> read() |> eval(env)
		}
	}
}

