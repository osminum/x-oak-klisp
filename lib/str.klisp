; string library, modeled after oak/libstr

(defn char-between? (c start end)
      (& (<= start c) (<= c end)))

(defn upper? (c)
      (char-between? c 'A' 'Z'))

(defn lower? (c)
      (char-between? c 'a' 'z'))

(defn digit? (c)
      (char-between? c '0' '9'))

(defn space? (c)
      (| (= c ' ')
         (= c '\t')
         (= c '\n')
         (= c '\r')
         (= c '\f')))

(defn letter? (c)
      (| (upper? c) (lower? c)))

(defn word? (c)
      (| (letter? c) (digit? c)))

(defn join (strings joiner)
      (do
        (default joiner '')
        (if (nil? strings)
          ''
          (do
            (defn -join (acc strings)
                  (if (nil? strings)
                    acc
                    (-join (+ acc joiner (car strings))
                           (cdr strings))))
            (-join (car strings) (cdr strings))))))

(defn starts-with? (s prefix)
      (= (gets s 0 (len prefix))
         prefix))

(defn ends-with? (s suffix)
      (= (gets s (- (len s) (len prefix)))
         suffix))

(defn str-index (s substr)
      (do
        (defn -iter (i)
              (if (<= (len s) i)
                -1
                (if (= (gets s i (+ i (len substr))) substr)
                  i
                  (-iter (inc i)))))
        (-iter 0)))

(defn str-contains? (s substr)
      (<= 0 (str-index s substr)))

(defn cut (s sep)
      (let (cut-at (str-index s sep))
        (list (gets s 0 cut-at)
              (gets s (+ cut-at (len sep))))))

; (defn upper)
; (defn lower)

(defn matches-at? (s substr i)
      (= (gets s i (+ i (len substr)))
         substr))

; (defn replace)
; (defn split)
; (defn pad-start)
; (defn pad-end)
; (defn trim-start)
; (defn trim-end)
; (defn trim)

